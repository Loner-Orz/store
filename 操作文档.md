# store商城项目

## 预备工作

项目结构：com.cy.store

项目依赖：java web，my batis，mysql driver

资源文件：resorces文件下的（static，templates）

### 单元测试：test.com.cy.store

#### 1.在properties配置数据库连接信息

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/store?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=password
```

#### 2.创建一个store数据库

```mysql
creat database store character set utf8;
```

#### 3.测试连接

- 启动springboot的主类，是否有对应的spring图形输出
- 在单元测试类中测试数据库的连接是否可以正常加载

#### 4.访问项目静态资源是否可以正常加载，将所有静态资源复制到static目录下

[^注意]:idea对于JS代码的兼容性较差，编写的JS代码有时候不能正常加载。

- idea缓存清理
- clear - install
- rebuild重构
- 重启idea和操作系统

## 用户注册

### 1.创建数据表

#### 1. 选中数据表

```mysql
use store
```

#### 2.创建t_user表

```mysql
CREATE TABLE t_user (
	uid INT AUTO_INCREMENT COMMENT '用户id',
	username VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名',
	password CHAR(32) NOT NULL COMMENT '密码',
	salt CHAR(36) COMMENT '盐值',
	phone VARCHAR(20) COMMENT '电话号码',
	email VARCHAR(30) COMMENT '电子邮箱',
	gender INT COMMENT '性别:0-女，1-男',
	avatar VARCHAR(50) COMMENT '头像',
	is_delete INT COMMENT '是否删除：0-未删除，1-已删除',
	created_user VARCHAR(20) COMMENT '日志-创建人',
	created_time DATETIME COMMENT '日志-创建时间',
	modified_user VARCHAR(20) COMMENT '日志-最后修改执行人',
	modified_time DATETIME COMMENT '日志-最后修改时间',
	PRIMARY KEY (uid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

####  3.创建用户的实体类

- 通过表的结构提取出表的公共字段，放在一个实体类的基类中，起名BaseEntity基类

  ```java
  /**
   * 作为实体类的基类
   */
  //@Data
  public class BaseEntity implements Serializable {
      private String createdUser;
      private Data createdTime;
      private String modifiedUser;
      private Data modifiedTime;
  
  
      public String getCreatedUser() {
          return createdUser;
      }
  
      public void setCreatedUser(String createdUser) {
          this.createdUser = createdUser;
      }
  
      public Data getCreatedTime() {
          return createdTime;
      }
  
      public void setCreatedTime(Data createdTime) {
          this.createdTime = createdTime;
      }
  
      public String getModifiedUser() {
          return modifiedUser;
      }
  
      public void setModifiedUser(String modifiedUser) {
          this.modifiedUser = modifiedUser;
      }
  
      public Data getModifiedTime() {
          return modifiedTime;
      }
  
      public void setModifiedTime(Data modifiedTime) {
          this.modifiedTime = modifiedTime;
      }
  
      @Override
      public boolean equals(Object o) {
          if (this == o) return true;
          if (!(o instanceof BaseEntity)) return false;
          BaseEntity that = (BaseEntity) o;
          return Objects.equals(getCreatedUser(), that.getCreatedUser()) && Objects.equals(getCreatedTime(), that.getCreatedTime()) && Objects.equals(getModifiedUser(), that.getModifiedUser()) && Objects.equals(getModifiedTime(), that.getModifiedTime());
      }
  
      @Override
      public int hashCode() {
          return Objects.hash(getCreatedUser(), getCreatedTime(), getModifiedUser(), getModifiedTime());
      }
  
      @Override
      public String toString() {
          return "BaseEntity{" +
                  "createdUser='" + createdUser + '\'' +
                  ", createdTime=" + createdTime +
                  ", modifiedUser='" + modifiedUser + '\'' +
                  ", modifiedTime=" + modifiedTime +
                  '}';
      }
  }@Override
      public String toString() {
          return "BaseEntity{" +
                  "createdUser='" + createdUser + '\'' +
                  ", createdTime=" + createdTime +
                  ", modifiedUser='" + modifiedUser + '\'' +
                  ", modifiedTime=" + modifiedTime +
                  '}';
      }
  ```

- 创建用户的实体类，需要继承BaseEntity基类

  ```java
  /**
   * 用户的实体类 SpringBoot约定大于配置
   */
  public class User extends BaseEntity implements Serializable {
      private Integer uid;
      private String username;
      private String password;
      private String salt;
      private String phone;
      private String email;
      private Integer gender;
      private String avatar;
      private Integer is_delete;
  
      //get和set方法,equals和hashCode()方法,toString()方法
  
      public Integer getUid() {
          return uid;
      }
  
      public void setUid(Integer uid) {
          this.uid = uid;
      }
  
      public String getUsername() {
          return username;
      }
  
      public void setUsername(String username) {
          this.username = username;
      }
  
      public String getPassword() {
          return password;
      }
  
      public void setPassword(String password) {
          this.password = password;
      }
  
      public String getSalt() {
          return salt;
      }
  
      public void setSalt(String salt) {
          this.salt = salt;
      }
  
      public String getPhone() {
          return phone;
      }
  
      public void setPhone(String phone) {
          this.phone = phone;
      }
  
      public String getEmail() {
          return email;
      }
  
      public void setEmail(String email) {
          this.email = email;
      }
  
      public Integer getGender() {
          return gender;
      }
  
      public void setGender(Integer gender) {
          this.gender = gender;
      }
  
      public String getAvatar() {
          return avatar;
      }
  
      public void setAvatar(String avatar) {
          this.avatar = avatar;
      }
  
      public Integer getIs_delete() {
          return is_delete;
      }
  
      public void setIs_delete(Integer is_delete) {
          this.is_delete = is_delete;
      }
  
      @Override
      public boolean equals(Object o) {
          if (this == o) return true;
          if (!(o instanceof User)) return false;
          if (!super.equals(o)) return false;
          User user = (User) o;
          return Objects.equals(getUid(), user.getUid()) && Objects.equals(getUsername(), user.getUsername()) && Objects.equals(getPassword(), user.getPassword()) && Objects.equals(getSalt(), user.getSalt()) && Objects.equals(getPhone(), user.getPhone()) && Objects.equals(getEmail(), user.getEmail()) && Objects.equals(getGender(), user.getGender()) && Objects.equals(getAvatar(), user.getAvatar()) && Objects.equals(getIs_delete(), user.getIs_delete());
      }
  
      @Override
      public int hashCode() {
          return Objects.hash(super.hashCode(), getUid(), getUsername(), getPassword(), getSalt(), getPhone(), getEmail(), getGender(), getAvatar(), getIs_delete());
      }
  
      @Override
      public String toString() {
          return "User{" +
                  "uid=" + uid +
                  ", username='" + username + '\'' +
                  ", password='" + password + '\'' +
                  ", salt='" + salt + '\'' +
                  ", phone='" + phone + '\'' +
                  ", email='" + email + '\'' +
                  ", gender=" + gender +
                  ", avatar='" + avatar + '\'' +
                  ", is_delete=" + is_delete +
                  '}';
      }
      
  }
  ```



### 2.注册-持久层（mapper）

通过MyBatis操作数据库，在做MyBatis开发的流程

#### 2.1规划需要执行的sql语句

- 用户注册功能相当于在做数据插入操作

  ```mysql
  insert into t_user(username,password) values(值列表)
  ```

- 在用户注册时首先去查询当前用户名是否存在，如果存在则不能注册，相当于一条查询语句

  ```mysql
  select* from t_user where username=?
  ```

  

#### 2.2设计接口和抽象方法

定义Mapper接口。在项目目录结构的文件下创建一个名为mapper的包，在这个包下再根据不同的功能模块来创建mapper接口。

创建UserMapper接口,在接口中定义这两个SQl语句的抽象方法

```java
/**
 * 用户模块的持久层接口
 */
public interface UserMappper {
    /**
     * 插入用户的数据
     * @param user 用户的数据
     * @return 返回值是受影响的行数（增，删，改都受影响，可根据返回值判断操作是否成功）
     */
    Integer insert(User user);

    /**
     * 根据用户名来查询用户数据
     * @param username 用户名
     * @return  如果找到用户名则返回对应数据，如果没有找到则返回NULL值
     */
    User findByUsername(String username);
}
```

在启动类配置Mapper接口文件的位置

```java
//MapperScan注解指定当前项目中的Mapper接口路径的位置，在项目启动的时候会自动的加载所有接口
@MapperScan("com.cy.Mapper")
```



#### 2.3编写映射

定义xml映射文件，与对应接口进行关联。所有的映射文件需要放置在resource目录下

- 一般会在resource下创建mapper文件夹，用于存放Mapper的映射文件
- 创建接口做对应的映射文件，遵循和接口的名称保持一致的原则即可。则创建一个UserMapper.xml的文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <!--namespeace的属性：用于指定当前的映射文件和那个接口文件映射，所以需要指定接口的文件路径，需要标注包的完整路径接口-->
<mapper namespace="com.cy.store.Mapper.UserMapper">

</mapper>
```

- 配置接口方法对应上SQL语句，需要借助标签来完成，insert\update\delete\select,对应sql语句的增删改查操作

  ```xml
  <!--自定义映射规则：resultMap标签来完成映射规则的定义-->
      <!--
          id属性：标签给这个映射负责分配一个唯一的id值，相对应的resultMap=“id属性的值”
          type属性：取值是一个类，表示的是数据库中的查询结果与java中的哪个实体类进行结果集的映射
      -->
      <resultMap id="UserEntityMap" type="com.cy.store.entity.User">
          <!--将表的资源和类的属性不一致的字段进行匹配，名称一致的可以省略-->
          <!--
              column属性:表中的资源名称
              property属性:类中的属性名称
          -->
          <!--在定义映射规则时主键不能省略，无论名称是否一致-->
          <result column="uid" property="uid"></result>
          <result column="is_delete" property="isDelete"></result>
          <result column="created_user" property="createdUser"></result>
          <result column="created_time" property="createdTime"></result>
          <result column="modified_user" property="modifiedUser"></result>
          <result column="modified_time" property="modifiedTime"></result>
      </resultMap>
  
      <!--id的值表示映射的接口中方法的名称，直接在标签的内部编写sql语句-->
      <!--
          useGeneratedKeys属性：表示开启某字段的值递增(一般为主键)
          KeyProperty属性：表示将表中的哪个字段作为逐渐递增
      -->
      <insert id="insert" useGeneratedKeys="true" KeyProperty="uid">
          INSERT INTO t_user(
              username,password,salt,phone,email,gender,
          	avatar,is_delete,created_user,created_time,modified_user,modified_time
          )VALUES(
              #{username},#{password},#{salt},#{phone},#{email},#{gender},
              #{avatar},#{isDelete},#{createdUser},#{createdTime},#{modifiedUser},#{modifiedTime}
          )
      </insert>
      <!--select语句在执行的时候，查询的结果是一个对象，多个对象-->
      <!--
          resultType:表示查询的结果集类型，只需要指定对应映射类的类型，并且包含完整接口
          resultMap:标签当表的资源和类的对象属性字段名不一致时，用来自定义查询结果集的映射规则
      -->
      <select id="findByUsername" resultMap="UserEntityMap">
          SELECT* FROM t_user WHERE username = #{username}
      </select>
  
  
  ```

  - 将mapper文件的位置注册到properties对应的配置文件中

    ```properties
    mybatis.mapper-locations=classpath:mapper/*.xml
    ```

  - 单元测试

    ```java
    //@SpringBootTest:表示标注当前的类是一个测试类，不会随项目一块打包
    @SpringBootTest
    //启动单元测试类，需要传递一个SpringRunner.class
    @RunWith(SpringRunner.class)
    public class UserMapperTests {
        /**
         * 单元测试方法不启动整个项目，单独运行的条件：
         * 1.必须被test注解所修饰
         * 2.返回值类型必须是void
         * 3.方法的参数列表不能指定任何的类型
         * 4.方法的返回修饰值必须是public
         */
    
        @Autowired
        private UserMappper userMapper;
        @Test
        public void insert(){
            User user = new User();
            user.setUsername("tim");
            user.setPassword("123");
            Integer rows = userMapper.insert(user);
            System.out.println(rows);
        }
        @Test
        public void findByUsername(){
            User user = userMapper.findByUsername("tim");
            System.out.println(user);
        }
    }
    ```

    

### 3.注册-业务层（service）

![service](D:\桌面\store\service.png)

#### 3.1规划异常

- 将java的RuntimeException异常作为子类，在定义具体的异常类型来继承。业务层异常的基类ServiceException异常继承RuntimeException异常。异常机制建立。

  ```java
  package com.cy.store.service.ex;
  /**
   * 业务层异常的基类：throw new ServiceException("业务层产生的未知的异常")
   */
  public class ServiceException extends RuntimeException{
      public ServiceException() {
          super();
      }
  
      public ServiceException(String message) {
          super(message);
      }
  
      public ServiceException(String message, Throwable cause) {
          super(message, cause);
      }
  
      public ServiceException(Throwable cause) {
          super(cause);
      }
  
      protected ServiceException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
          super(message, cause, enableSuppression, writableStackTrace);
      }
  }
  ```

  根据业务层不同的业务功能来详细定义具体的异常的类型，统一的继承ServiceException异常类。

- 用户注册时用户名被占用，抛出异常：UsernameDuplicatedException

  ```java
  package com.cy.store.service.ex;
  //用户名被占用的异常
  public class UsernameDuplicatedException extends ServiceException{
      public UsernameDuplicatedException() {
          super();
      }
  
      public UsernameDuplicatedException(String message) {
          super(message);
      }
  
      public UsernameDuplicatedException(String message, Throwable cause) {
          super(message, cause);
      }
  
      public UsernameDuplicatedException(Throwable cause) {
          super(cause);
      }
  
      protected UsernameDuplicatedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
          super(message, cause, enableSuppression, writableStackTrace);
      }
  }
  ```

- 正在执行数据插入操作的时候，服务器或数据库宕机。处于正在执行插入的过程中所产生的异常InsertException异常。

  ```java
  package com.cy.store.service.ex;
  //数据在插入过程中所产生的异常
  public class InsertException extends ServiceException{
      public InsertException() {
          super();
      }
  
      public InsertException(String message) {
          super(message);
      }
  
      public InsertException(String message, Throwable cause) {
          super(message, cause);
      }
  
      public InsertException(Throwable cause) {
          super(cause);
      }
  
      protected InsertException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
          super(message, cause, enableSuppression, writableStackTrace);
      }
  }
  ```


#### 3.2设计接口和抽象方法

- 在service包下创建一个IUserService接口

  ```java
  package com.cy.store.service;
  
  import com.cy.store.entity.User;
  
  //用户模块业务层接口
  public interface IUserService {
      /**
       * 用户注册方法
       * @param user
       */
      void reg(User user);
  }
  
  ```

- 创建一个实现类UserServiceImpl类，需要实现这个接口，并实现抽象方法。

  ```java
  package com.cy.store.service.impl;
  
  import com.cy.store.entity.User;
  import com.cy.store.mapper.UserMappper;
  import com.cy.store.service.IUserService;
  import com.cy.store.service.ex.InsertException;
  import com.cy.store.service.ex.UsernameDuplicatedException;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Service;
  import org.springframework.util.DigestUtils;
  
  import java.time.LocalDate;
  import java.time.ZoneId;
  import java.util.Date;
  import java.util.UUID;
  
  @Service//@Service注解：将当前类交给Spring来管理，自动创建对象以及对象的维护
  //用户模块业务层的实现类
  public class UserServiceImpl implements IUserService {
      @Autowired
      private UserMappper userMappper;
  
      @Override
      public void reg(User user) {
          //通过user参数来获取传递过来的username
          String username = user.getUsername();
          //调用findByUsername(username)判断用户是否被注册过
          User result = userMappper.findByUsername(username);
          //判断结果集是否不为NULL则抛出用户名被占用的异常
          if(result != null){
              //抛出异常
              throw new UsernameDuplicatedException("用户名被占用");
          }
  
          //密码加密处理的实现：MD5算法的形式：（盐值+password+盐值）再交给MD5进行加密，连续加载三次。
          //盐值就是一个随机的字符串
          String oldPassword = user.getPassword();
          //获取盐值(随机生成)
          String salt = UUID.randomUUID().toString().toUpperCase();
          //补全数据：盐值
          user.setSalt(salt);
          //将密码和盐值进行加密处理
          String md5Password = getMD5Password(oldPassword,salt);
          //将加密之后的密码补全到user对象中
          user.setPassword(md5Password);
  
          //补全数据：is_delete==0
          user.setIsDelete(0);
          //补全数据：4个日志字段信息
          user.setCreatedUser(user.getUsername());
          user.setModifiedUser(user.getUsername());
          Date date = new Date();
          LocalDate localDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
          user.setCreatedTime(localDate);
          user.setModifiedTime(localDate);
  
          //执行注册业务功能的实现(rows==1)
          Integer rows = userMappper.insert(user);
          if (rows != 1){
              throw new InsertException("在用户注册过程中产生了未知的异常");
          }
      }
  
      //定义一个MD5算法的加密
      private String getMD5Password(String password, String salt){
  
          for(int i = 0;i < 3; i++){
              //md5加密算法的调用
              password = DigestUtils.md5DigestAsHex((salt+password+salt).getBytes()).toUpperCase();
          }
          //返回加密之后的密码
          return password;
      }
  
  }
  
  ```


#### 3.3单元测试：在测试包创建UserServiceTests类并添加测试功能。

```java
package com.cy.store.service;

import com.cy.store.entity.User;
import com.cy.store.service.ex.ServiceException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;


//@SpringBootTest:表示标注当前的类是一个测试类，不会随项目一块打包
@SpringBootTest
//启动单元测试类，需要传递一个SpringRunner.class
@RunWith(SpringRunner.class)
public class UserServiceTests {
    /**
     * 单元测试方法不启动整个项目，单独运行的条件：
     * 1.必须被test注解所修饰
     * 2.返回值类型必须是void
     * 3.方法的参数列表不能指定任何的类型
     * 4.方法的返回修饰值必须是public
     */

    @Autowired
    private IUserService userService;
    @Test
    public void reg(){
        try {
            User user = new User();
            user.setUsername("yuanxin02");
            user.setPassword("123");
            userService.reg(user);
            System.out.println("OK");
        } catch (ServiceException e) {
            //先获取类的对象再获取异常的名称
            System.out.println(e.getClass().getSimpleName());
            //获取异常的具体描述信息
            System.out.println(e.getMessage());
        }
    }
}

```



### 4.注册-控制层

#### 4.1创建响应

- 状态码，状态描述信息，数据。这部分功能封装在一个类中，将这个类作为方法的返回值，返回给前端浏览器。

  ```java
  /**
   * Json格式的数据据进行响应
   */
  public class JsonResult<E> implements Serializable {
      //状态码
      private Integer state;
      //描述信息
      private String messsge;
      //数据
      private E data;
    }
  ```

  

#### 4.2设计请求

- 依据当前的业务功能模块进行请求的设计。

  ```
  请求路径：/user/reg
  请求参数：User user
  请求类型：POST
  响应结果：JsonResult<void>
  ```

#### 4.3处理请求

- 创建一个控制层对应的类UserController类，此类依赖于业务层的接口

  ```java
  package com.cy.store.controller;
  
  import com.cy.store.entity.User;
  import com.cy.store.service.IUserService;
  import com.cy.store.service.ex.InsertException;
  import com.cy.store.service.ex.UsernameDuplicatedException;
  import com.cy.store.util.JsonResult;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RestController;
  
  //@Controller
  @RestController //相当于@Controller+@ResponseBody
  @RequestMapping("users")
  public class UserController {
      @Autowired
      private IUserService userService;
  
      @RequestMapping("reg")
      //@ResponseBody表示此方法的响应结果以json格式进行数据的响应给到前端
      public JsonResult<Void> reg(User user){
          //创建响应结果对象
          JsonResult<Void> result = new JsonResult<>();
          try {
              userService.reg(user);
              result.setState(200);
              result.setMesssge("用户注册成功");
          } catch (UsernameDuplicatedException e) {
              result.setState(4000);
              result.setMesssge("用户名被占用");
          } catch (InsertException e) {
              result.setState(5000);
              result.setMesssge("注册时产生未知异常");
          }
          return result;
      }
  
  
  }
  ```

#### 4.4将控制层进行优化设计

- 在控制层抽离一个父类，在这个父类统一的处理关于异常的相关的内容操作。编写一个类，统一处理异常。

  ```java
  public class BaseController {
      public static final int OK = 200;
  
      //请求处理方法，这个方法的返回值就是需要传递给前端的数据
      //自动将异常对象传递给此方法的参数列表上
      //当项目中发生了异常，被统一拦截到此方法中，这个方法此时就充当的是请求处理方法，方法返回值直接给到前端
      @ExceptionHandler(ServiceException.class)//用于统一处理抛出的异常
      public JsonResult<Void> handleException(Throwable e){
          JsonResult<Void> result = new JsonResult<>(e);
          if(e instanceof UsernameDuplicatedException){
              result.setState(4000);
              result.setMesssge("用户名被占用");
          }else if(e instanceof InsertException){
              result.setState(5000);
              result.setMesssge("注册时产生未知异常");
          }
          return result;
      }
  }
  
  ```
  
- 重新构建了reg()方法。

  ```java
  @RequestMapping("reg")
      //@ResponseBody表示此方法的响应结果以json格式进行数据的响应给到前端
      public JsonResult<Void> reg(User user){
          userService.reg(user);
          return new JsonResult<>(OK);
      }
  ```

### 5.注册-前端页面

- 在register页面中编写发送请求的方法，借助前端的点击事件来完成。先选中对应的按钮（$("选择器")），再去添加点击的事件，$.ajax()函数发送异步请求。
- JQUery封装了一个函数，称之为$.ajax()函数，通过对象调用ajax函数，可以异步加载相关请求。依靠的是JavaScript提供的一个对象XHR（XmlHttpResponse），封装了这个对象。
- ajax()使用方式。需要传递一个方法体作为方法的参数来使用，一对大括号称之为方法体。ajax接收了多个参数,参数与参数之间用","分割，每一组参数之间使用":"分割。参数的组成部分一个是参数的名称（不能随意定义），一个是参数的值要求使用字符串来表示。参数的声明顺序没有要求。
- 语法结构：

```js
$.ajax({
	url:"",
	type:"",
	data:"",
	dataType:"",
	success:function(){
	
	},
	error:function(){
	
	}
});
```

- ajax（）函数参数的含义：

  | 参数     | 功能描述                                                     |
  | -------- | ------------------------------------------------------------ |
  | url      | 表示请求的地址,不能包含参数列表的内容。例如：url："localhost:8080/users/reg" |
  | type     | 请求的类型（GET和POST请求类型）。例如：type："POST"          |
  | data     | 向指定的请求url地址提交的数据。例如：data："username=Tom&password=123456" |
  | dataType | 提交的数据类型，数据类型一般指定为json类型。例如：dataType："json" |
  | success  | 当服务器正常响应客户端时，会自动调用success参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上。 |
  | error    | 当服务器未响应客户端时，会自动调用error参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上。 |

- js代码可以独立声明在一个后缀为js的文件里或声明在一个script标签中。

  ```js
  <script type="text/javascript">
  			//1.监听注册按钮是否被点击,如果被点击可以执行一个方法
  			$("#btn-reg").click(function (){
  				/**动态获取表单中控件的数据
  				*  let username = $("#username").val();
  				*  let pwd = $("#password").val();
  				**/
  
  
  				//2.发送ajax（）的异步请求来完成用户的注册功能
  				$.ajax({
  					url:"/users/reg",
  					type:"POST",
  					data:$("#form-reg").serialize(),
  					//data:"username="+username+"password="+pwd,
  					dataType:"JSON",
  					success:function(json){
  						if (json.state == 200){
  							alert("注册成功");
  						}else{
  							alert("注册失败");
  						}
  					},
  					error:function(xhr){
  						alert("注册时产生未知的错误！"+xhr.status);
  					}
  				});
  			});
  
  		</script>
  ```

  

## 用户登录

- 当用户输入用户名和密码将数据提交给后台数据库进行查询，如果存在对应用户名和密码则表示登陆成功，登录成功之后跳转到系统主页index.html页面，跳转在前端使用JQuery来完成。

### 1.登录-持久层 

#### 1.1规划需要执行的sql语句

- 依据用户提交的用户名和密码做select查询，密码的比较放在业务层处理。

  ```sql
  select* from t_user where username = ?
  ```

- 如果分析过程中发现某个功能已经被开发完成，就可以省略当前开发步骤，但这个分析过程不能省略。

#### 1.2设计接口和抽象方法

- 不用重复开发，单元测试也无需单独执行。

### 2.登录-业务层

#### 2.1规划异常

1. 用户名对应的密码错误，密码匹配失败的异常：PasswordNotMatchException异常，运行时异常，业务异常。

   ```java
   package com.cy.store.service.ex;
   
   /** 密码验证失败的异常 */
   public class PasswordNotMatchException extends ServiceException {
       public PasswordNotMatchException() {
           super();
       }
   
       public PasswordNotMatchException(String message) {
           super(message);
       }
   
       public PasswordNotMatchException(String message, Throwable cause) {
           super(message, cause);
       }
   
       public PasswordNotMatchException(Throwable cause) {
           super(cause);
       }
   
       protected PasswordNotMatchException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
           super(message, cause, enableSuppression, writableStackTrace);
       }
   }
   ```

   

2. 用户名没有被找到，抛出异常：UserNotFoundException异常，运行时异常，业务异常。

   ```java
   package com.cy.store.service.ex;
   
   /** 用户数据不存在的异常 */
   public class UserNotFoundException extends ServiceException {
       public UserNotFoundException() {
           super();
       }
   
       public UserNotFoundException(String message) {
           super(message);
       }
   
       public UserNotFoundException(String message, Throwable cause) {
           super(message, cause);
       }
   
       public UserNotFoundException(Throwable cause) {
           super(cause);
       }
   
       protected UserNotFoundException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
           super(message, cause, enableSuppression, writableStackTrace);
       }
   }
   ```

   

3. 异常的编写：

   - 业务层异常需要继承ServiceException异常类
   - 在具体的异常类中定义构造方法（可以使用快捷键来生成，有5个构造方法）

#### 2.2设计接口和抽象方法

1. 直接在IUserSerivce接口中编写抽象方法，login(String username,String password)。将当前登陆成功的用户数据以当前用户对象的形式进行返回。状态管理：可以将数据保存至cookie和session中，可以避免重复度很高的数据频繁操作数据库（用户名，用户id存放于session中，用户头像保存在cookie中）。

   ```java
   /**
        * 用户登录方法
        * @param username 用户名
        * @param password 用户密码
        */
       User login(String username, String password);
       }
   ```

   

2. 需要在实现类中实现父接口中的抽象方法。

   ```java
   @Override
       public User login(String username, String password){
           //根据用户名称来查询数据是否存在，如果不存在则抛出异常
           User result = userMappper.findByUsername(username);
           if (result == null){
               throw new UserNotFoundException("用户数据不存在");
           }
           //检测用户密码是否匹配
           //1.先获取数据库中加密后的密码
           String oldPassword = result.getPassword();
           //2.和用户传递过来的密码进行比较
           //2.1获取盐值：上一次注册时生成的盐值
           String salt = result.getSalt();
           //2.2将用户密码按照相同的md5算法规则进行加密
           String newMd5Password = getMD5Password(password,salt);
           //将密码进行比较
           if (!newMd5Password.equals(oldPassword)){
               throw new PasswordNotMatchException("用户密码错误");
           }
           //判断is_delete字段的值是否为1表示标记为被删除
           if (result.getIsDelete() == 1){
               throw new UserNotFoundException("用户数据不存在");
           }
   
           //数据返回是为了辅助其他页面做数据展示使用的（uid,username,avatar）提升了系统性能。
           User user = new User();
           user.setUid(result.getUid());
           user.setUsername(result.getUsername());
           user.setAvatar(result.getAvatar());
   
           //将当前用户数据返回
           return user;
       }
   ```

#### 2.3单元测试

1. 在测试类中测试业务层登录的方法是否可以执行通过

   ```java
   @Test
       public void login(){
           User user = userService.login("test01","123456");
           System.out.println(user);
       }
   ```

### 3.登录-控制层

#### 3.1处理异常

业务层抛出的异常是什么，需要在统一异常处理类中进行统一的捕获和处理，如果抛出异常类型已经存在，则无需重复添加。

```java
		else if(e instanceof UserNotFoundException){
            result.setState(5001);
            result.setMesssge("用户数据不存在异常");
        }else if(e instanceof PasswordNotMatchException){
            result.setState(5002);
            result.setMesssge("用户密码错误的异常");
        }
```



#### 3.2设计请求

```
请求路径：/users/login
请求方式：POST
请求数据：String username, String password，HttpSession session
响应结果：JsonResult<User>
```



#### 3.3处理请求

在UserController类中编写处理请求方法。

```java
@RequestMapping("login")
    public JsonResult<User> login(String username,String password){
        User data = userService.login(username,password);
        return new JsonResult<>(OK,data);
    }
```



### 4.登录-前端页面

#### 4.1在login.html页面依据前面所设置的请求来发送ajax请求。

```js
<script type="text/javascript">
			$("#btn-login").click(function (){
				$.ajax({
					url:"/users/login",
					type:"POST",
					data:$("#form-login").serialize(),
					dataType:"JSON",
					success:function(json){
						if (json.state === 200){
							alert("登陆成功");
							//跳转到系统主页面
							//相对路径来确定跳转页面
							location.href = "index.html";
						}else{
							alert("登陆失败");
						}
					},
					error:function(xhr){
						alert("登陆时产生未知异常"+xhr.message);
					}
				});
			});
		</script>
```

#### 4.2用户会话session

- session对象主要存在服务器端，可以用于保存服务器的临时数据的对象，所保存的数据在整个项目都可以访问获取，把session数据看成一个共享数据。首次登陆时所获取到的用户数据转移到session对象即可。session.getAttrbute("key")可以将获取session中的数据这种行为进行封装，封装在BaseController类中。

1. 封装session对象中数据的获取（封装在父类中），数据的设置（当用户登录后进行数据的设置，设置到全局的session对象）

2. 在父类中封装两个数据：获取uid和获取username对应的两个方法。用户头像暂时不考虑，将来封装到cookie中。

   ```java
       /**
        * 获取session对象中的uid
        * @param session session对象
        * @return 当前登录用户的uid
        */
       protected final Integer getuidFromSession(HttpSession session){
           return Integer.valueOf(session.getAttribute("uid").toString());
       }
   
       /**
        * 获取session对象中的username
        * @param session session对象
        * @return 当前登录用户的username
        */
       protected final String getUsernameFromSession(HttpSession session){
           return  session.getAttribute("username").toString();
       }
   ```

3. 在登陆的方法中将数据封装在session对象中。又服务器本身自动创建有session对象，已经是一个全局的session对象了。spring boot可以直接使用session对象，直接将HttpSession类型的对象作为请求处理方法的参数，会自动将全局的session对象注入到请求处理方法的session形参上。

   ```java
    //向session对象中完成对象的绑定（session是全局的）
           session.setAttribute("uid",data.getUid());
           session.setAttribute("username",data.getUsername());
   ```

## 拦截器

- 拦截器：首先将所有的请求统一拦截到拦截器中，可以在拦截器中定义过滤的规则，如果不满足系统设置的过滤规则，统一处理是重新打开login.html页面（重回定向和转发），推荐使用重定向。
- 在spring boot项目中拦截器的定义和使用。spring boot依靠springmvc来完成的，springmvc提供了一个HandlerInterceptor接口用于表示定义一个拦截器。首先是自定义一个类，再在这个类实现这个接口。

### 1.定义一个拦截器

- #### 首先自定义一个类，使其实现HandlerInterceptor接口

```java
/** 定义一个拦截器 */
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 检测全局session对象中是否有uid，如果有则放行，如果没有则重定向到登录页面
     * @param request 请求对象
     * @param response 响应对象
     * @param handler 处理器（url+Controller的映射）
     * @return 如果返回值为true表示放行当前请求，如果返回值为flase表示拦截当前请求
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) throws Exception {
        //HttpServletRequest来获取session对象
        Object obj = request.getSession().getAttribute("uid");
        if (obj == null){
            //用户没有登录，则重定向到登录页面
            response.sendRedirect("/web/login.html");
            //结束后续的调用
            return false;
        }
        //请求放行
        return true;
    }
}
```

HandlerInterceptor源码解析：

```java
public interface HandlerInterceptor {
    //在调用所有处理请求的方法之前被自动的调用执行的方法
    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        return true;
    }

    //在ModelAndview对象返回之后被调用的方法
    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
    }

    //在整个请求所有关联的资源被执行完毕最后所执行的方法
    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {
    }
}
```

### 2.注册过滤器

1. 添加白名单（可以在不登录的情况下访问：login.html，register.html，reg，index.html，product.html）
2. 添加黑名单(在用户登陆的状态下才可以访问的页面资源)
3. 注册过滤器技术：借助WebMvcConfigurer接口，可以将用户定义的拦截器注册，才可以保证拦截器生效和使用。定义一个类，让这个类实现WebMvcConfigurer接口。配置信息建议存放在项目的config包结构下。

```java
//将自定义的拦截器进行注册
default void addInterceptors(InterceptorRegistry registry) {
    }
```

```java
/** 处理器拦截器的注册 */
@Configuration //加载当前的拦截器并进行注册
public class LoginInterceptorConfigurer implements WebMvcConfigurer {

    /** 配置拦截器 */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //创建自定义拦截器的对象
        HandlerInterceptor interceptor = new LoginInterceptor();

        //配置白名单：存放在一个list集合
        List<String> patterns = new ArrayList<>();
        patterns.add("/bootstrap3/**");
        patterns.add("/css/**");
        patterns.add("/images/**");
        patterns.add("/js/**");
        patterns.add("/web/login.html");
        patterns.add("/web/register.html");
        patterns.add("/web/index.html");
        patterns.add("/web/product.html");
        patterns.add("/users/reg");
        patterns.add("/users/login");

        //完成拦截器的注册
        registry.addInterceptor(interceptor)
                .addPathPatterns("/**") //表示要拦截的url是什么
                .excludePathPatterns(patterns);
    }
}
```

## 修改密码

- 需要用户提交原始密码和新密码，再根据当前登录的用户进行信息的修改操作

### 1.修改密码-持久层

#### 1.1规划需要执行的sql语句

- 根据用户的uid修改用户password的值

  ```mysql
  update t_user set password=?,modified_user=?,modified_time=? where uid=？ 
  ```

- 根据uid查询用户的数据。再修改密码前，首先要保证当前用户数据存在，是否被标记已经删除，检测输入的原始密码是否正确。

  ```mysql
  select* from t_user where uid=?
  ```

#### 1.2设计接口和抽象方法

- UserMapper接口，将以上两个方法抽象定义出来，将来映射到两条SQL语句上。

  ```java
  /**
       * 根据用户的uid来修改用户的密码
       * @param uid 用户的uid
       * @param password 用户输入的新密码
       * @param modifiedUser 表示修改的执行者
       * @param modifiedTime 表示修改的时间
       * @return 返回值是受影响的行数
       */
      Integer updatePasswordByUid(Integer uid,
                                  String password,
                                  String modifiedUser,
                                  LocalDate modifiedTime);
  
      /**
       * 根据用户uid查询用户数据
       * @param uid 用户的uid
       * @return 如果找到则返回对象，反之返回null
       */
      User findByUid(Integer uid);
  ```

#### 1.3SQL语句的映射

- 将这两个方法配置到映射文件UserMapper.xml中

  ```sql
      <update id="updatePasswordByUid">
          UPDATE t_user SET
          password=#{password},
          modified_user=#{modifiedUser},
          modified_time=#{modifiedTime}
          WHERE uid=#{uid}
      </update>
  
      <select id="findByUid" resultMap="UserEntityMap">
          SELECT * FROM t_user WHERE uid=#{uid}
      </select>
  ```

#### 1.4单元测试

```java
@Test
    public void updatePasswordByUid(){
        userMapper.updatePasswordByUid(8,"321","管理员",new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
    }

    @Test
    public void findByUid(){
        System.out.println(userMapper.findByUid(8));
    }
```

### 2.修改密码-业务层

#### 2.1规划可能产生的异常

1. 用户的原密码错误，is_delete==1，uid找不到（用户没有发现的异常）。

2. 在更新时，有可能产生未知异常，UpdateException异常。

   ```java
   /** 用户在更新时产生的未知异常 */
   public class UpdateException extends ServiceException{
       public UpdateException() {
           super();
       }
   
       public UpdateException(String message) {
           super(message);
       }
   
       public UpdateException(String message, Throwable cause) {
           super(message, cause);
       }
   
       public UpdateException(Throwable cause) {
           super(cause);
       }
   
       protected UpdateException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
           super(message, cause, enableSuppression, writableStackTrace);
       }
   }
   ```

#### 2.2设计接口和抽象方法

- 执行用户修改密码的核心方法。

  ```java
  void changePssword(Integer uid,
                     String username,
                     String oldPssword,
                     String newPassword
                   );
  ```

- 在实现类中实现当前抽象方法

  ```java
   @Override
      public void changePassword(Integer uid, String username, String oldPssword, String newPassword){
          User result = userMappper.findByUid(uid);
          if (result == null|| result.getIsDelete() == 1){
              throw new UserNotFoundException("用户数据不存在");
          }
          //原始密码和数据库中密码进行比较
          String oldMd5Password = getMD5Password(oldPssword,result.getSalt());
          if (!result.getPassword().equals(oldMd5Password)){
              throw new PasswordNotMatchException("密码错误");
          }
          //将新密码设计进数据库，新密码先加密再更新
          String newMd5Password = getMD5Password(newPassword, result.getSalt());
          Integer rows = userMappper.updatePasswordByUid( uid,
                                                          newMd5Password,
                                                          username,
                                                          new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
          if(rows != 1){
              throw new UpdateException("更新数据产生未知异常");
          }
      }
  ```

#### 2.3单元测试

- 在单元测试类中编写测试方法

  ```java
  @Test
      public void changePassword(){
         userService.changePssword(7,"管理员","123","321");
      }
  ```

  

### 3.修改密码-控制层

#### 3.1处理异常

- UptateException需要配置在统一的异常处理方法中。

  ```java
  else if(e instanceof UpdateException){
              result.setState(5003);
              result.setMesssge("更新数据时产生未知异常");
  }
  ```

  

#### 3.2设计请求

```
请求路径：/users/change_password
请求方式：POST
请求数据：String oldPassword, String newPassword,HttpSession session  //需要和表单中的name属性值保持一致
响应结果：JsonResult<Void>
```



#### 3.3处理请求

```java
@RequestMapping("change_password")
    public JsonResult<Void> changePassword(String oldPassword,
                                           String newPassword,
                                           HttpSession session){
        Integer uid = getuidFromSession(session);
        String username = getUsernameFromSession(session);
        userService.changePssword(uid,username,oldPassword,newPassword);
        return new JsonResult<>(OK);
    }
```

### 4.修改密码-前端页面

password.html页面添加ajax请求的处理，不再手动编写ajax整体结构了，直接复制再微调修改参数即可。

```js
<script type="text/javascript">
			$("#btn-change-password").click(function (){
				$.ajax({
					url:"/users/change_password",
					type:"POST",
					data:$("#form-change-password").serialize(),
					dataType:"JSON",
					success:function(json){
						if (json.state === 200 ){
							alert("密码修改成功");
							//跳转到系统主页面
							//相对路径来确定跳转页面
							location.href = "index.html";
						}else{
							alert("密码修改失败");
						}
					},
					error:function(xhr){
						alert("修改密码时产生未知异常"+xhr.message);
					}
				});
			});
		</script>
```

## 个人资料

### 1.个人资料-持久层

#### 1.1规划需要执行的sql语句

- 更新用户信息的sql语句

  ```sql
  uptate t_user set phone=?,email=?,gender=?,modified_user=?,modified_time=? where uid=?
  ```

- 根据用户名来查询用户数据

  ```sql
  select* from t_user where uid=?
  ```

  查询用户数据重复，不需要再开发。

#### 1.2设计接口类型和抽象方法

- 更新用户信息方法updateInfoByUid()的定义。

```java
 /**
     * 根据用户uid更新用户信息
     * @param user 用户数据
     * @return 返回值为受影响的行数
     */
    Integer updateInfoByUid(User user);
```



#### 1.3sql语句的映射

- 在UserMapper.xml文件中进行映射编写。

```xml
<update id="updateInfoByUid">
        UPDATE t_user SET
        <!--if表示条件判断标签，test接收返回值为boolean类型的条件
        如果test结果为true，则执行if标签内部的语句，反之则不执行-->
        <if test="phone!=null">phone=#{phone},</if>
        <if test="email!=null">email=#{email},</if>
        <if test="gender!=null">gender=#{gender},</if>
        modified_user=#{modifiedUser},
        modified_time=#{modifiedTime}
        WHERE uid=#{uid}
    </update>
```

#### 1.4单元测试

- 在测试类中完成功能的测试

  ```java
   @Test
      public void uptateInfoByUid(){
          User user = new User();
          user.setUid(9);
          user.setPhone("18508053212");
          user.setEmail("test02@qq.com");
          user.setGender(1);
          userMapper.updateInfoByUid(user);
      }
  ```

### 2.个人资料-业务层

#### 2.1异常规划

1. 设计两个功能：

   - 打开页面是获取用户信息并且填充到对应的文本框中

   - 用户是否点击了修改按钮，如果检测到则执行修改用户信息的操作

2. 打开页面时可能找不到用户数据，点击修改按钮之前需要再次检测用户数据是否存在。

#### 2.2设计接口和抽象方法

主要有两个功能的模块，对应两个抽象方法。

```java
/**
     *根据用户uid查询用户数据
     * @param uid 用户id
     * @return 返回用户数据
     */
    User getByUid(Integer uid);

    /**
     * 更新用户数据的操作
     * @param uid 用户id
     * @param username 用户名
     * @param user 用户对象的数据
     */
    void changeInfo(Integer uid,
                    String username,
                    User user);
```



#### 2.3实现抽象方法

- 在UserSerivceImpl类中添加两个抽象方法的具体实现类。

  ```java
      @Override
      public User getByUid(Integer uid){
          User result = userMappper.findByUid(uid);
          if (result == null || result.getIsDelete() == 1) {
              throw new UserNotFoundException("用户数据不存在");
          }
  
          User user = new User();
          user.setUsername(result.getUsername());
          user.setPhone(result.getPhone());
          user.setEmail(result.getEmail());
          user.setGender(result.getGender());
          return user;
      }
  
      @Override
      public User changeInfo(Integer uid,String username,User user){
          User result = userMappper.findByUid();
          if (result == null || result.getIsDelete() == 1) {
              throw new UserNotFoundException("用户数据不存在");
          }
          user.setUid(uid);
          user.setUsername(username);
          user.setModifiedUser(username);
          user.setModifiedTime(new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
  
          Integer rows = userMappper.updateInfoByUid(user);
          if(rows != 1){
              throw new UpdateException("用户数据更新失败");
          }
      }
  ```

#### 2.4单元测试

- 在测试类中进行单元测试

  ```java
    @Test
      public void getByUid(){
          System.err.println(userService.getByUid(9));
  
      }
  
      @Test
      public void  changeInfo(){
          User user = new User();
          user.setPhone("17731288888");
          user.setEmail("test02@gmail.com");
          user.setGender(0);
          userService.changeInfo(9,"test02",user);
      }
  ```

  

### 3.个人资料-控制层

#### 3.1处理异常

- 暂无

#### 3.2设计请求

1. 设置用户一打开页面就发送当前用户数据的查询

   ```
   请求路径：/users/get_by_uid
   请求方式：GET
   请求数据：HttpSession session
   响应结果：JsonResult<User>
   ```

2. 点击修改按按钮发送数据修改操作请求的设计

   ```
   请求路径：/users/change_info
   请求方式：POST
   请求数据：HttpSession session,User user
   响应结果：JsonRuselt<Void>
   ```

#### 3.3处理请求

```java
    @RequestMapping("get_by_uid")
    public JsonResult<User> getByUid(HttpSession session){
        User date = userService.getByUid(getuidFromSession(session));
        return new JsonResult<>(OK,date);
    }

    @RequestMapping("change_info")
    public JsonResult<Void> changeInfo(User user,
                                       HttpSession session){
        //User有四部分数据：username，phone，email，gender
        Integer uid = getuidFromSession(session);
        String username = getUsernameFromSession(session);
        userService.changeInfo(uid,username,user);
        return new JsonResult<>(OK);
    }
```

### 4.个人资料-前端页面

1. 用户打开userdata.html页面自动发送ajax请求(get_by_uid)，并且将查询到的数据填充到页面上。

   ```js
   /**
   			 * 一旦检测到当前页页面被加载就会触发ready方法
   			 * $(document).ready(function(){
   			 *     //编写业务代码
   			 * });
   			 */
   			$(document).ready(function (){
   				$.ajax({
   					url:"/users/get_by_uid",
   					type:"GET",
   					data:$("#form-change-info").serialize(),
   					dataType:"JSON",
   					success:function(json){
   						if (json.state === 200 ){
   							//将查询到的数据重新设置到控件中
   							$("#username").val(json.data.username);
   							$("#phone").val(json.data.phone);
   							$("#email").val(json.data.email);
   							let radio = json.data.gender === 0 ?
   									$("#gender-female") : $("#gender-male");
   							//prop(属性，属性值)表示给某个属性添加属性值
   							radio.prop("checked","checked");
   						}else{
   							alert("信息修改失败");
   						}
   					},
   					error:function(xhr){
   						alert("修改信息时产生未知异常"+xhr.message);
   					}
   				});
   			});
   ```

   

2. 在检测到用户点击了修改按钮之后发送一个ajax请求(change_info)。

   ```js
   
   			$("#btn-change-info").click(function (){
   				$.ajax({
   					url:"/users/change_info",
   					type:"POST",
   					data:$("#form-change-info").serialize(),
   					dataType:"JSON",
   					success:function(json){
   						if (json.state === 200 ){
   							alert("用户信息修改成功");
   							//修改成功后重新加载页面
   							location.href="userdata.html";
   						}else{
   							alert("用户信息修改失败");
   						}
   					},
   					error:function(xhr){
   						alert("修改用户信息时产生未知异常"+xhr.message);
   					}
   				});
   			});
   ```

## 上传头像

### 1.上传头像-持久层

#### 1.1规划执行的sql语句

- 将对应文件保存在操作系统上，然后把文件路径记录。在数据库只需要保存这个文件路径即可。

- 对应的是一个更新用户avatar字段的sql语句

  ```sql
  ipdate t_user set avatar=?, modified_user=?, modified_time=? where uid=?
  ```

#### 1.2设计接口类型和抽象方法

```java
/**
     * @param("sql映射文件中#{}占位符的变量名")：用于解决SQL语句占位符和映射的接口方法参数名不一致时强行注入
     * 根据用户uid更新用户头像
     * @param uid 用户uid
     * @param avatar 用户头像数据
     * @param modifiedUser 表示修改的执行者
     * @param modifiedTime 表示修改的时间
     * @return
     */
    Integer updateAvatarByUid(@Param("uid")  Integer uid,
                              @Param("avatar")  String avatar,
                              @Param("modifiedUser")  String modifiedUser,
                              @Param("modifiedTime")  LocalDate modifiedTime);
```



#### 1.3sql语句的映射

- UserMapper.xml文件中编写映射的sql语句。

  ```sql
     <update id="updateAvatarByUid">
          UPDATE t_user
          SET
              avatar=#{avatar},
              modified_user=#{modifiedUser},
              modified_time=#{modifiedTime}
          WHERE
              uid=#{uid}
      </update>
  ```

#### 1.4单元测试

- 在测试类中编写测试方法

  ```java
  @Test
      public void updateAvatarByUid(){
          userMapper.updateAvatarByUid(10,
                                       "/user/avatar.jpg",
                                       "管理员",
                                       new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
      }
  ```

### 2.上传头像-业务层

#### 2.1规划异常

1. 用户数据不存在，找不到对应的用户数据。UserNotFountException
2. 更新的时候，各种未知异常UpdateException

#### 2.2设计接口和抽象方法

```javascript
/**
     * 更新用户头像的操作
     * @param uid 用户id
     * @param avatar 用户更新的头像路径
     * @param username 用户名称
     */
    void changeAvatar(Integer uid,
                      String avatar,
                      String username);
```

#### 2.3实现抽象方法

```java
    @Override
    public void changeAvatar(Integer uid, String avatar, String username) {
        //查询当前用户数据是否存在
        User result = userMappper.findByUid(uid);
        if (result == null || result.getIsDelete() == 1) {
            throw new UserNotFoundException("用户数据不存在");
        }
        //更新头像
        Integer rows = userMappper.updateAvatarByUid( uid,
                                                      avatar,
                                                      username,
                                                      new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
        if (rows != 1){
            throw new UpdateException("更新用户头像产生未知异常");
        }
    }
```

#### 2.4单元测试

- 测试业务层方法执行是否正确

  ```java
  @Test
      public void changeAvatar(){
          userService.changeAvatar( 10,
                                  "/user/test.png",
                                  "小明");
      }
  ```

### 3.上传头像-控制层

#### 3.1规划异常

1. FileUploadException    泛指文件上传的异常（作为文件异常的父类）并且去继承RuntimeException异常
2. FileEmptyException      文件为空的异常
3. FileSizeException         文件大小超出限制
4. FileTypeException        文件类型异常
5. FileUploadIOException 文件读写异常
6. FileStateException        文件的状态异常

#### 3.2处理异常

- 在BaseController统一进行编写和处理

  ```java
  	   else if (e instanceof FileEmptyException) {
              result.setState(6000);
          } else if (e instanceof FileSizeException) {
              result.setState(6001);
          } else if (e instanceof FileTypeException) {
              result.setState(6002);
          } else if (e instanceof FileStateException) {
              result.setState(6003);
          } else if (e instanceof FileUploadIOException) {
              result.setState(6004);
          }
  ```

- 在异常统一处理方法的参数列表上增加新的异常处理作为它的参数

  ```java
  @ExceptionHandler({ServiceException.class,FileUploadException.class})//用于统一处理抛出的异常
  ```

#### 3.3设计请求

```
请求路径：/users/change_avatar
请求方式：POST
请求数据：HttpSession session, MutipartFile file
响应结果：JsonResult<String>
```

#### 3.4实现请求

```java
    /** 设置上传文件的最大值 */
    public static final int AVATAR_MAX_SIZE = 10*1024*1024;

    /** 设置限制上传文件的类型 */
    public static final List<String> AVATAR_TYPE = new ArrayList<>();
    //用静态库给集合初始化
    static {
        AVATAR_TYPE.add("images/jpeg");
        AVATAR_TYPE.add("images/png");
        AVATAR_TYPE.add("images/gif");
        AVATAR_TYPE.add("images/bmp");
    }

    /**
     * MultipartFile接口是由SpringMVC提供的，为我们包装了获取文件类型的数据(任何类型文件都可以接收)
     * @RequestParam表示请求中的参数，将请求的参数注入请求处理方法的某个参数上，如果名称不一致则使用@RequestPara进行映射
     * @param session
     * @param file
     * @return
     */
    @RequestMapping("change_avatar")
    public JsonResult<String> changeAvatar(HttpSession session,
                                           @RequestParam("file") MultipartFile file){
        //判断文件是否为null
        if (file.isEmpty()){
            throw new FileEmptyException("文件为空");
        }
        //文件大小判断
        if (file.getSize() > AVATAR_MAX_SIZE){
            throw new FileSizeException("文件超出大小限制");
        }
        //判断文件类型是否是规定的类型
        String contentType = file.getContentType();
        if (!AVATAR_TYPE.contains(contentType){
            throw new FileTypeException("文件类型不支持");
        }
        //上传的文件.../upload/文件.jpg
        String parent = session.getServletContext().getRealPath("upload");
        //File对象指向这个路径，判断File是否存在
        File dir = new File(parent);
        if (!dir.exists()){//检测目录是否存在
            dir.mkdirs();//创建目录
        }
        //获取当前文件名
        String originalFilename = file.getOriginalFilename();
        System.out.println("OriginalFilename="+originalFilename);
        //截取文件后缀
        int index = originalFilename.lastIndexOf('.');
        String suffix = originalFilename.substring(index);
        //再用UUID来生成新的字符串作为文件名
        String filename = UUID.randomUUID().toString().toUpperCase() + suffix;
        //创建以新文件名命名的空文件
        File dest = new File(dir,filename);
        //将参数file中的数据写入到这个空文件
        try {
            file.transferTo(dest);
        }catch (FileStateException e){
            throw new FileStateException("文件状态异常");
        }catch (IOException e) {
            throw new FileUploadIOException("文件读写异常");
        }
        //调用头像修改
        Integer uid = getuidFromSession(session);
        String username = getUsernameFromSession(session);
        //返回头像路径：.../upload/filename
        String avatar = "/ipload/"+filename;
        userService.changeAvatar(uid,
                                 avatar,
                                 username);
        //返回用户头像的路径给前端，作为前端展示头像使用
        return new JsonResult<>(OK,avatar);
    }
```

### 4.上传头像-前端页面

- 在upload.html页面中编写头像的代码

  *如果使用表单进行文件的上传，必须给表单显示的添加enctype="multipart/form-data"声明出来，不会将目标文件的结构做修改再上传，不同于字符串*

- 利用前端表单提交文件

```js
action="/users/change_avatar"
method="post"
enctype="multipart/form-data"
```

### 5.前端优化

#### 5.1更改默认大小限制

springMVC默认1MB大小的文件可以上传，手动的去修改springMVC默认上传大小。

方式1：直接在配置文件中进行配置

```properties
spring.servlet.multipart.maxFileSize=10MB
spring.servlet.multipart.maxRequestSize=15MB
```

方式2：采用java代码的形式来限制上传文件大小，在主类中进行配置：

- 可以定义一个方法，必须使用@Bean修饰符来进行修饰。在类的前面添加@Configuration注解进行修饰类。返回值是MutipartConfigElement类型

```java
 @Bean
    public MultipartConfigElement getMultipartConfigElement(){
        //创建一个配置的工厂类对象
        MultipartConfigFactory factory = new MultipartConfigFactory();

        //设置需要创建的对象的相关信息
        factory.setMaxFileSize(DataSize.of(10, DataUnit.MEGABYTES));
        factory.setMaxRequestSize(DataSize.of(15, DataUnit.MEGABYTES));

        //通过工厂类来创建MultipartConfigElement对象
        return factory.createMultipartConfig();
    }
```

#### 5.2显示处理头像

- 在页面中通过ajax请求来提交文件，提交完成后返回json串，解析出data中的数据，设置到img头像的src属性上。

- .serialize()可以将表单数据自动拼接成key=value的结构进行体提交，一般提交的是普通的控件类型数据（text\password\redio\checkbox）等等。

- FormData类：将表单中的数据保持原有的结构进行数据的提交。

  ```js
  new FormDta($("#form")[0]); //特殊类型的数据可以用FormDta对象来进行存储
  ```

- ajax默认处理数据是按照字符串的形式进行处理，以及默认会采用字符串的形式进行提交数据，我们就需要关闭这两个默认的功能。

  ```js
  processData:false, //表示关闭以串的形式处理数据
  contentType:false, //表示关闭以串的形式提交数据
  ```

#### 5.3登陆后显示头像

头像更新成功后，将服务器返回的头像路径保存在客户端cookie对象中，每次检测到用户打开上传头像页面，在页面中通过ready方法自动检测读取cookie中的头像路径并复制到img标签的src属性上。

1. 设置cookie中的值：

   导入cookie.js文件

   ```js
   <script src="../bootstrap3/js/jquery.cookie.js" type="text/javascript" charset="utf-8"></script>
   ```

   调用cookie方法

   ```js
   $.cookie(key,value,time); //时间单位：天
   ```

2. 在upload.html页面使用ready()函数自动读取cookie数据

   ```js
   $(document).ready(function () {
   				//将cookie中的头像获取并保存到img标签的src属性中
   				let avatar = $.cookie("avatar");
   				$("img-avatar").attr("src",avatar)
   			});
   ```

#### 5.4未显示最新头像

再更改完头像后，将最新的头像地址，再次保存到cookie中，同名保存会覆盖原有cookie中的值

```js
//将头像保存到cookie中
$.cookie("avatar",json.data.avatar,{expires:7});
```

## 新增收货管理

### 1.新增收货地址-数据库表的建立

```sql
CREATE TABLE t_address (
	aid INT AUTO_INCREMENT COMMENT '收货地址id',
	uid INT COMMENT '归属的用户id',
	name VARCHAR(20) COMMENT '收货人姓名',
	province_name VARCHAR(15) COMMENT '省-名称',
	province_code CHAR(6) COMMENT '省-行政代号',
	city_name VARCHAR(15) COMMENT '市-名称',
	city_code CHAR(6) COMMENT '市-行政代号',
	area_name VARCHAR(15) COMMENT '区-名称',
	area_code CHAR(6) COMMENT '区-行政代号',
	zip CHAR(6) COMMENT '邮政编码',
	address VARCHAR(50) COMMENT '详细地址',
	phone VARCHAR(20) COMMENT '手机',
	tel VARCHAR(20) COMMENT '固话',
	tag VARCHAR(6) COMMENT '标签',
	is_default INT COMMENT '是否默认：0-不默认，1-默认',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (aid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

### 2.新增收货地址-创建实体类

创建一个Address类，在类中定义表中的相关数据字段，采用驼峰命名，再去继承BaseEntity基类

```java
package com.cy.store.entity;
import java.io.Serializable;

/** 收货地址数据的实体类 */
public class Address extends BaseEntity implements Serializable {
    private Integer aid;
    private Integer uid;
    private String name;
    private String provinceName;
    private String provinceCode;
    private String cityName;
    private String cityCode;
    private String areaName;
    private String areaCode;
    private String zip;
    private String address;
    private String phone;
    private String tel;
    private String tag;
    private Integer isDefault;
    // Generate: Getter and Setter、Generate hashCode() and equals()、toString()
}
```

### 3.新增收货管理-持久层

### 3.1需要规划执行的sql语句

当前收货地址功能模块：列表的展示，修改，删除，设置默认，新增收货地址。

开发顺序：新增收货地址-列表的展示-设置默认地址-删除收货地址-修改收货地址。

- 新增收货地址：对应插入语句

  ```sql
  insert into t_address (除了aid以外的字段列表) value （字段值列表）
  ```

- 一个用户收货地址规定最多只能有20条，所有再插入之前要先做查询操作。

  ```sql
  select count(*) from t_address where uid=?
  ```

### 3.2设计接口类型和抽象方法

创建一个AddressMapper接口，在接口中定义两个sql语句的抽象方法。

```java
package com.cy.store.mapper;

import com.cy.store.entity.Address;

/** 收货地址持久层的接口 */
public interface AddressMapper {

    /**
     *插入用户的收货地址数据
     * @param address 收货地址数据
     * @return 受影响的行数
     */
    Integer insert(Address address);

    /**
     * 根据用户id查询用户收货地址数量
     * @param uid 用户id
     * @return 当前用户的收货地址数量
     */
    Integer countByUid(Integer uid);
}
```

### 3.3sql语句的映射

创建一个叫AddressMapper.xml的映射文件，并且在这个文件中添加抽象方法的映射。

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace的属性：用于指定当前的映射文件和哪个接口文件映射，所以需要指定接口的文件路径，需要标注包的完整路径接口-->
<mapper namespace="com.cy.store.mapper.AddressMapper">
    <resultMap id="AddressEntityMap" type="com.cy.store.entity.Address">
        <id column="aid" property="aid"/>
        <result column="province_code" property="provinceCode"/>
        <result column="province_name" property="provinceName"/>
        <result column="city_code" property="cityCode"/>
        <result column="city_name" property="cityName"/>
        <result column="area_code" property="areaCode"/>
        <result column="area_name" property="areaName"/>
        <result column="is_default" property="isDefault"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>

    <insert id="insert" useGeneratedKeys="true" keyProperty="aid">
        INSERT INTO
        t_address (
            uid, name, province_name, province_code, city_name, city_code, area_name, area_code, zip,
            address, phone, tel, tag, is_default, created_user, created_time, modified_user, modified_time )
        VALUES (
            #{uid}, #{name}, #{provinceName}, #{provinceCode}, #{cityName}, #{cityCode}, #{areaName},
            #{areaCode}, #{zip}, #{address}, #{phone}, #{tel}, #{tag}, #{isDefault}, #{createdUser},
            #{createdTime}, #{modifiedUser}, #{modifiedTime} )
    </insert>

    <select id="countByUid" resultType="java.lang.Integer">
        SELECT count(*)
        FROM
            t_address
        WHERE
            uid=#{uid}
    </select>
</mapper>
```

### 3.4单元测试

在test下的mapper创建AddressMapperTests的测试类。

```java
 @Test
    public void insert(){
        Address address = new Address();
        address.setUid(10);
        address.setPhone("123123434567");
        address.setName("女朋友");
        addressMapper.insert(address);
    }

    @Test
    public void countByUid(){
        Integer count = addressMapper.countByUid(10);
        System.out.println(count);
    }
```

### 4.新增收货管理-业务层

#### 4.1规划异常

如果用户插入的是第一条收货地址时，需要将当前的地址设置为默认收货地址。如果查询到当前统计数为0，则将当前数据的is_default的值设置为1。

如果查询结果大于20则需要抛出业务控制的异常AddressCountLimitException异常。

```java
package com.cy.store.service.ex;

/** 收货地址总数超出限制的异常（20条） */
public class AddressCountLimitException extends ServiceException{
    public AddressCountLimitException() {
        super();
    }

    public AddressCountLimitException(String message) {
        super(message);
    }

    public AddressCountLimitException(String message, Throwable cause) {
        super(message, cause);
    }

    public AddressCountLimitException(Throwable cause) {
        super(cause);
    }

    protected AddressCountLimitException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

插入数据时产生未知的异常insertException异常，不需要再进行重复创建。

#### 4.2设计接口和抽象方法

创建一个IAddressService接口，在这个接口中定义业务的抽象方法。

```java
package com.cy.store.service;

import com.cy.store.entity.Address;

/** 收货地址业务层接口 */
public interface IAddressService {

    void addNewAddress(Integer uid, String username, Address address);
}
```

#### 4.3实现抽象方法

在配置文件中定义数据

```properties
#Spring 读取配置文件中的数据：@value("${user.address.max-count}")
user.address.max-count=20
```

创建一个AddressServiceImpl的实现类，去实现接口中的抽象方法。

```java
/** 新增收货地址的实现类 */
@Service
public class AddressServiceImpl implements IAddressService {
    @Autowired
    private AddressMapper addressMapper;

    @Value("${user.address.max-count}")
    private Integer maxCount;

    @Override
    public void addNewAddress(Integer uid, String username, Address address) {
        //调用收货地址统计的方法
        Integer count = addressMapper.countByUid(uid);
        if (count >= maxCount){
            throw new AddressCountLimitException("用户收货地址超出限制");
        }
        //uid,isDefault
        address.setUid(uid);
        Integer isDefault = count == 0? 1:0;//1表示默认，0表示不默认
        address.setIsDefault(isDefault);
        //补全4项日志
        address.setCreatedUser(username);
        address.setCreatedTime(new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
        address.setModifiedUser(username);
        address.setModifiedTime(new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());

        //插入收货地址的方法
        Integer rows = addressMapper.insert(address);
        if (rows != 1){
            throw new InsertException("插入收货地址产生未知的异常");
        }
    }
}
```

#### 4.4单元测试

创建一个AddressServiceTests测试类来测试业务功能。

```java
//@SpringBootTest:表示标注当前的类是一个测试类，不会随项目一块打包
@SpringBootTest
//启动单元测试类，需要传递一个SpringRunner.class
@RunWith(SpringRunner.class)
public class AddressServiceTests {
    /**
     * 单元测试方法不启动整个项目，单独运行的条件：
     * 1.必须被test注解所修饰
     * 2.返回值类型必须是void
     * 3.方法的参数列表不能指定任何的类型
     * 4.方法的返回修饰值必须是public
     */

    @Autowired
    private IAddressService addressService;

    @Test
    public void addNewAddress(){
        Address address = new Address();
        address.setPhone("12312349999");
        address.setName("男朋友");
        addressService.addNewAddress(10,"管理员",address);
    }
}
```

### 5.新增收货管理-控制层

#### 5.1处理异常

业务层抛出了收货地址总数超出限制的异常，在BaseController中进行处理。

```java
else if(e instanceof AddressCountLimitException){
            result.setState(4003);
            result.setMesssge("用户收货地址超出限制的异常");
        }
```

#### 5.2设计请求

```
请求路径：/addresses/add_new_address
请求方式：POST
请求数据：HttpSession session,Address address
响应结果：JsonResult<void>
```

#### 5.3处理请求

在控制层创建一个新的AddressController来处理用户收货地址的请求和响应

```java
@RequestMapping("addresses")
@RestController
public class AddressController extends BaseController{
    @Autowired
    private IAddressService addressService;

    @RequestMapping("add_new_address")
    public JsonResult<Void> addNewAddress(Address address, HttpSession session){
        Integer uid = getuidFromSession(session);
        String username = getUsernameFromSession(session);
        addressService.addNewAddress(uid,username,address);
        return new JsonResult<>(OK);
    }
}
```

### 6.新增收货管理-前端页面

```js
		<script type="text/javascript">
			$("#btn-add-new-address").click(function (){
				$.ajax({
					url:"/addresses/add_new_address",
					type:"POST",
					data:$("#form-add-new-address").serialize(),
					dataType:"JSON",
					success:function(json){
						if (json.state === 200 ){
							alert("新增收货地址成功");
						}else{
							alert("新增收货地址失败");
						}
					},
					error:function(xhr){
						alert("新增收货地址时产生未知的错误！"+xhr.status);
					}
				});
			});
		</script>
```

## 获取省市区列表

### 1.创建省市区的数据库

```sql
CREATE TABLE t_dict_district (
  id int(11) NOT NULL AUTO_INCREMENT,
  parent varchar(6) DEFAULT NULL,
  code varchar(6) DEFAULT NULL,
  name varchar(16) DEFAULT NULL,
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

parent属性表示的是父区域的代码号，省的父代码号+86。

### 2.定义对应的实体类

创建一个District实体类

```java
/** 省市区的数据实体类 */
public class District extends BaseEntity{
    private Integer id;
    private String parent;
    private String code;
    private String name;
}
```

### 3.获取省市区列表-持久层

#### 3.1查询语句，根据父代号进行查询。

```sql
select * from t_district where parent=? oder by code ASC
```

#### 3.2抽象方法的定义。DistrictMapper接口

```java
public interface DistrictMapper {
    /**
     * 根据父代号查询区域信息
     * @param parent 父代号
     * @return 某个父区域下的所有列表
     */
    List<District>findByParent(Integer parent);
}
```

### 4.获取省市区列表-业务层

#### 4.1创建接口IDistrictService并定义抽象方法。

```java
public interface IDistrictService {
    /**
     * 根据父代码来查询区域的信息
     * @param parent 父代码
     * @return 区域信息
     */
    List<District> getByParent(String parent);
}
```

#### 4.2创建DistrictServiceImpl实现类，并实现抽象方法

```java
@Service
public class DistrictServiceImpl implements IDistrictService {
    @Autowired
    private DistrictMapper districtMapper;

    @Override
    public List<District> getByParent(String parent) {
        List<District> list = districtMapper.findByParent(parent);
        /**
         * 在进行网络数据传输时，为了尽量避免无效数据传输，可以将无效值设置为null
         * 可以节省流量，另一方面提升了效率
         */
        for (District d : list){
            d.setId(null);
            d.setParent(null);
        }
        return list;
    }
}
```

#### 4.3单元测试

```java
@Test
    public void getByParent(){
        List<District> list = districtService.getByParent("86");
        for (District d: list){
            System.err.println(d);
        }
    }
```

### 5.获取省市区列表-控制层

#### 5.1设计请求

```
请求路径：/districts/
请求方式：GET
请求数据：String parent
响应结果：JsonResult<List<District>>
```

#### 5.2请求方法

创建一个DistrictController类，在类中编写处理请求的方法。

```java
@RequestMapping("districts")
@RestController
public class DistrictController extends BaseController{
    @Autowired
    private IDistrictService districtService;
    
    @RequestMapping({"/",""})
    public JsonResult<List<District>> getByParent(String parent){
        List<District> data = districtService.getByParent(parent);
        return new JsonResult<>(OK,data);
    }
}
```

district请求添加到白名单中

```java
  patterns.add("/districts/**");
```

### 6.获取省市区列表-前端页面

注释掉通过js来完成的省市区列表代码

```js
<!--
<script type="text/javascript" src="../js/distpicker.data.js"></script>
<script type="text/javascript" src="../js/distpicker.js"></script>
-->
```

检查前端页面提交省市区数据时是否有相关name和id属性。

运行前端是否可以正常保存数据（除省市区外）

## 获取省市区名称

### 1.获取省市区名称-持久层

#### 1.1根据当前code来获取当前省市区的名称，对应一条查询语句

```sql
select * from t_dist_district where code=?
```

#### 1.2在DistrictMapper接口中定义findNameByCode

```java
/**
     * 根据当前code来获取当前省市区的名称
     * @param code 当前code
     * @return 省市区名称
     */
    String findNameByCode(String code);
```

#### 1.3在DistrictMapper.xml文件中添加抽象方法的映射

```xml
<select id="findNameByCode" resultType="java.lang.String">
        SELECT name
        FROM t_dict_district
        WHERE code=#{code}
    </select>
```

#### 1.4单元测试

```java
@Test
    public void findNameByCode(){
        String name = districtMapper.findNameByCode("610000");
        System.out.println(name);
    }
```

### 2.获取省市区名称-业务层

#### 2.1在业务曾没有异常需要进行处理。

#### 2.2定义对应的业务层接口中的抽象方法。

```java
String getNameByCode(String code);
```

#### 2.3把抽象方法在子类中实现

```java
 @Override
    public String getNameByCode(String code) {
        return districtMapper.findNameByCode(code);
    }
```

#### 2.4单元测试

可以省略不写

### 3.获取省市区名称-业务层优化

在添加地址层依赖于IDistrictService的业务层

```java
//在添加用户的收货地址的业务层依赖于DistirctService的业务层
    @Autowired
    private IDistrictService iDistrictService;
```

在addNewAddress方法中将districtService接口中获取到的省市区数据转移到address对象中，找个对象就包含了所有的收货地址的数据

```java
//在添加用户的收货地址的业务层依赖于DistirctService的业务层
    @Autowired
    private IDistrictService districtService;
    
  //对address对象中的数据进行补全：省市区
        String provinceName = districtService.getNameByCode(address.getProvinceCode());
        String cityName = districtService.getNameByCode(address.getCityCode());
        String areaName = districtService.getNameByCode(address.getAreaCode());
        address.setAddress(provinceName);
        address.setCityName(cityName);
        address.setAreaName(areaName);
```

### 4.获取省市区名称-前端页面

#### 4.1在addAddress.html页面中来编写对应的省市区展示及用户不同的选择来限制对应标签的内容。

```js
	<script type="text/javascript">
			//value属性表示当前这个区域的code值
			let defaultOption = "<option value='0'>---- 请选择 ----</optionvalue>"
			$(document).ready(function () {
				showProvinceList();
				//设置默认的”请选择“的值作为控件的默认值
				$("#area-list").append(defaultOption);
				$("#city-list").append(defaultOption);
			});

			//省的下拉列表数据展示
			function showProvinceList(){
				$.ajax({
					url: "/districts",
					type: "POST",
					data: "parent=86",
					dataType: "JSON",
					success: function (json) {
						if (json.state === 200) {
							let list = json.data;
							for (let i = 0; i < list.length;i++){
								let opt =
										"<option value='"+list[i].code+"'>"+list[i].name+"</option>"
								$("#province-list").append(opt);
							}
						} else {
							alert("省/直辖区信息加载失败！");
						}
					}
				});
			}

			/**
			 * change函数用于监听某个控件是否发生改变，一旦发生就会触发
			 * 需要传递一个function(){}
			 */
			$("#province-list").change(function (){
				//先获取行政区父代码
				let parent = $("#province-list").val();
				//清空select下拉列表中的所有option元素
				$("#city-list").empty();
				$("#area-list").empty();
				//再填充默认值
				$("#city-list").append(defaultOption);
				$("#area-list").append(defaultOption);

				if(parent == 0){
					return;
				}

				$.ajax({
					url:"/districts",
					type:"GET",
					data:"parent="+parent,
					dataType:"JSON",
					success:function (json) {
						if (json.state === 200) {
							let list = json.data;
							for (let i = 0; i < list.length;i++){
								let opt =
										"<option value='"+list[i].code+"'>"+list[i].name+"</option>"
								$("#city-list").append(opt);
							}
						} else {
							alert("城市信息加载失败！");
						}
					}
				});
			});

			$("#city-list").change(function (){
				let parent = $("#city-list").val();
				//清空select下拉列表中的所有option元素
				$("#area-list").empty();
				//再填充默认值
				$("#area-list").append(defaultOption);

				if(parent == 0){
					return;
				}

				$.ajax({
					url:"/districts",
					type:"GET",
					data:"parent="+parent,
					dataType:"JSON",
					success:function (json) {
						if (json.state === 200) {
							let list = json.data;
							for (let i = 0; i < list.length;i++){
								let opt =
										"<option value='"+list[i].code+"'>"+list[i].name+"</option>"
								$("#area-list").append(opt);
							}
						} else {
							alert("区县信息加载失败！");
						}
					}
				});
			});

			$("#btn-add-new-address").click(function (){
				$.ajax({
					url:"/addresses/add_new_address",
					type:"POST",
					data:$("#form-add-new-address").serialize(),
					dataType:"JSON",
					success:function(json){
						if (json.state === 200 ){
							alert("新增收货地址成功");
						}else{
							alert("新增收货地址失败");
						}
					},
					error:function(xhr){
						alert("新增收货地址时产生未知的错误！"+xhr.status);
					}
				});
			});
		</script>
```

## 收货地址列表展示

### 1.收货地址列表展示-持久层

#### 1.1数据库数据的查询操作

```sql
select * from t_address where uid=? oder by is_default DESC, created_time DESC
```

#### 1.2接口的设计和抽象方法

```java
/**
     * 根据用户id查询用户的收货地址数据
     * @param uid 用户id
     * @return 收货地址数据
     */
    List<Address> findByUid(Integer uid);
```

#### 1.3sql语句的映射

```xml
<select id="findByUid" resultMap="AddressEntityMap">
        SELECT *
        FROM
            t_address
        WHERE
            uid=#{uid}
        ODER BY
            is_default DESC,created_time DESC
    </select>
```

#### 1.4单元测试

```java
@Test
    public void findByUid(){
        List<Address> list = addressMapper.findByUid(10);
        System.out.println(list);
    }
```

### 2.收货地址列表展示-业务层

#### 2.1规划异常

获取的列表仅仅用作展示，不需要抛出异常。

#### 2.2设计业务层接口和抽象方法

```java
 List<Address> getByUid(Integer uid);
```

#### 2.3实现抽象方法

```java
@Override
    public List<Address> getByUid(Integer uid) {
        List<Address> list = addressMapper.findByUid(uid);
        for (Address address : list){
            address.setAid(null);
            address.setUid(null);
            address.setProvinceCode(null);
            address.setCityCode(null);
            address.setAreaCode(null);
            address.setTel(null);
            address.setIsDefault(null);
            address.setCreatedUser(null);
            address.setCreatedTime(null);
            address.setModifiedUser(null);
            address.setModifiedTime(null);
        }
        return list;
    }
```

### 3.收货地址列表展示-控制层

#### 3.1请求设计

```
请求路径：/addresses
请求方式：GET
请求数据：HttpSession session
响应结果：JsonResult<List<Address>>
```

#### 3.2处理请求

```java
@RequestMapping({"/",""})
    public JsonResult<List<Address>> getByUid(HttpSession session){
        List<Address> data = addressService.getByUid(getuidFromSession(session));
        return new JsonResult<>(OK,data);
    }
```

#### 3.3单元测试

先登录再，再访问请求的地址

### 4.收货地址列表展示-前端页面

在address.html页面编写查询用户收货地址的数据的展示列表

```js
<script type="text/javascript">
			/** 展示收货地址数据列表 */
			function showAddressList(){
				$.ajax({
					url: "/addresses",
					type: "GET",
					dataType: "JSON",
					success: function (json) {
						if (json.state === 200) {
							let list = json.data;
							for (let i = 0; i < list.length;i++){
								let tr = '<tr>' +
										'<td>#{tag}</td>' +
										'<td>#{name}</td>' +
										'<td>#{address}</td>' +
										'<td>#{phone}</td>' +
										'<td><a class="btn btn-xs btn-info"><span class="fa fa-edit"></span> 修改</a></td>' +
										'<td><a class="btn btn-xs add-del btn-info"><span class="fa fa-trash-o"></span> 删除</a></td>' +
										'<td><a class="btn btn-xs add-def btn-default">设为默认</a></td>' +
										'</tr>';
								tr = tr.replace(/#{tag}/g,list[i].tag);
								tr = tr.replace(/#{name}/g,list[i].name);
								tr = tr.replace("#{phone}",list[i].phone);
								tr = tr.replace("#{address}",list[i].address);

								$("#address-list").append(tr);
							}
						//将某个元素隐藏可以使用hide()方法
						$(".add-def:eq(0)").hide();

						} else {
							alert("用户收货地址数据加载失败！");
						}
					}
				});
			}
			$(document).ready(function () {
				showAddressList();
			});
		</script>
```

## 设置默认收货地址

### 1.设置默认收货地址-持久层

#### 1.1sql语句规划

- 检测当前用户想判断默认收货地址的数据是否存在

  ```sql
  select * from t_affress where aid=?
  ```

- 在修改用户收货默认地址之前，现将所有的收货地址设置为非默认

  ```sql
  update t_address set is_default=0 where uid=?
  ```

- 将用户当前选中的记录设置为默认收货地址

  ```sql
  update t_address set is_default=1， modified_user=?, modified_time=? where aid=?
  ```

#### 1.2设计抽象方法

在AddressMapper接口中定义和声明

```java
  /**
     * 根据aid查询收货地址数据
     * @param aid 收货地址aid
     * @return 收货地址数据
     */
    Address findByAid(Integer aid);

    /**
     * 根据用户id设置用户所有收货地址设置非默认
     * @param uid 用户id
     * @return 受影响的行数
     */
    Integer updateNonDefault(Integer uid);


    /**
     * 根据aid设置用户的默认收货地址
     * @param aid 收货地址id
     * @return 受影响的行数
     */
    Integer updateDefaultByAid(
                               @Param("aid") Integer aid,
                               @Param("modifiedUser") String modifiedUser,
                               @Param("modifiedTime") LocalDate modifiedTime);
```

#### 1.3配置sql映射

在AddressMapper.xml文件中进行配置

```xml
<select id="findByAid" resultMap="AddressEntityMap">
        SELECT *
        FROM
            t_address
        WHERE
            aid=#{uid}
    </select>

    <update id="updateNonDefault">
        UPDATE t_address SET is_default=0 WHERE uid=#{uid}
    </update>

    <update id="updateDefaultByAid">
        UPDATE t_address
        SET is_default=1,
            modified_user=#{modifiedUser},
            modified_time=#{modifiedTime}
        WHERE aid=#{aid}
    </update>
```

#### 1.4单元测试

```java
 @Test
    public void findByAid(){
        System.err.println(addressMapper.findByAid(9));

    }

    @Test
    public void updateNonDefault(){
        addressMapper.updateNonDefault(10);
    }

    @Test
    public void updateDefaultByAid(){
        addressMapper.updateDefaultByAid(
                4,
                "管理员",
                new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
    }
```

### 2.设置默认收货地址-业务层

#### 2.1异常的规划

- 在执行更新时产生未知的UpdteException异常。(已经创建)
-  访问的数据不是当前登陆用户的数据，非法访问：AccessDeniedException异常。
- 收货地址不存在的异常：AddressNotFoundException异常

#### 2.2抽象方法

- 在IAddressSerivce接口中定义方法

  ```java
  /**
       * 修改某个用户的默认收货地址
       * @param aid 收货地址id
       * @param uid 用户id
       * @param username 修改执行人
       */
      void setDefault(Integer aid,
                      Integer uid,
                      String username);
  ```

#### 2.3实现抽象方法

- 在AddressSerivceImpl里实现方法

  ```java
  @Override
      public void setDefault(Integer aid, Integer uid, String username) {
          Address result = addressMapper.findByAid(aid);
          if (result == null){
              throw new AddressNotFoundException("收货地址不存在");
          }
          //检测当前获取到的收货地址的归属
          if (!result.getUid().equals(uid)){
              throw new AccessDeniedException("非法数据访问");
          }
          //先将所有的收货地址设置为非默认
          Integer rows = addressMapper.updateNonDefault(uid);
          if (rows < 1){
              throw new UpdateException("更新数据产生未知异常");
          }
          //将用户选中的数据设置为默认地址
          rows = addressMapper.updateDefaultByAid(aid,username,new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
          if (rows != 1){
              throw new UpdateException("更新数据产生未知异常");
          }
      }
  ```

#### 2.4单元测试

```java
 @Test
    public void setDefault(){
        addressService.setDefault(8,10,"test03");
    }
```

### 3.设置默认收货地址-控制层

#### 3.1处理相关异常

- 在BaseController类中进行统一处理

  ```java
  else if(e instanceof AddressNotFoundException){
              result.setState(4004);
              result.setMesssge("用户收货地址数据不存在的异常");
          }else if(e instanceof AccessDeniedException){
              result.setState(4005);
              result.setMesssge("非法访问数据的异常");
          }
  ```

#### 3.2设计请求

```
请求路径：/addresses/{aid}/set_default
请求方式：GET
请求数据：HttpSession session,@Pathvariable("aid") Integer aid
响应结果：JsonResult<Void>
```

#### 3.3处理请求

- 在AddressController类中编写请求处理方法

  ```java
  //restful风格的请求编写
      @RequestMapping("/{aid}/set_default")
      public JsonResult<Void> setDefault(  @PathVariable("aid") Integer aid,
                                           HttpSession session){
          addressService.setDefault(  aid,
                                      getuidFromSession(session),
                                      getUsernameFromSession(session));
          return new JsonResult<>(OK);
      }
  ```

### 4.设置默认收货地址-前端页面

- 给设置默认收货地址按钮添加一个onclick属性，执行一个方法的调用，在这个方法来完成ajax请求

  ```js
  let tr = '<tr>' +
  										'<td>#{tag}</td>' +
  										'<td>#{name}</td>' +
  										'<td>#{address}</td>' +
  										'<td>#{phone}</td>' +
  										'<td><a class="btn btn-xs btn-info"><span class="fa fa-edit"></span> 修改</a></td>' +
  										'<td><a class="btn btn-xs add-del btn-info"><span class="fa fa-trash-o"></span> 删除</a></td>' +
  										'<td><a onclick="setDefault(#{aid}})" class="btn btn-xs add-def btn-default">设为默认</a></td>' +
  										'</tr>';
  								tr = tr.replace(/#{tag}/g,list[i].tag);
  								tr = tr.replace(/#{name}/g,list[i].name);
  								tr = tr.replace("#{phone}",list[i].phone);
  								tr = tr.replace("#{address}",list[i].address);
  								tr = tr.replace("#{aid}",list[i].aid);
  ```

- address.html页面点击"设置默认"按钮时，发送ajax请求。完成setDefault()方法的定义和声明

  ```js
  function setDefault(aid){
  				$.ajax({
  					url:"/addresses/"+aid+"/set_default",
  					type:"POST",
  					dataType:"JSON",
  					success:function(json){
  						if (json.state === 200 ){
  							//重新加载收货地址
  							showAddressList();
  						}else{
  							alert("设置默认收货地址失败");
  						}
  					},
  					error:function(xhr){
  						alert("设置默认收货地址时产生未知异常"+xhr.message);
  					}
  				});
  			}
  ```

- 登陆测试

## 删除收货地址

### 1.删除收货地址-持久层

#### 1.1规划执行的sql语句

- 在删除之前判断该数据是否存在，判断该条地址是否属于当前用户。

- 执行删除收货地址信息

  ```sql
  delete from t_address where aid=?
  ```

- 如果用户删除的是默认收货地址，则将剩下的某一条地址设置为默认地址。规则：最新修改的地址设置为默认收货地址（modified_time）

  ```sql
  #limit (n-1)*n,pageSize
  select* from t_address where uid=? order by modified_time DESC limit 0,1
  ```

- 如果用户本身只有一条数据，删除后就不用做其他操作了

#### 1.2设计抽象方法

在AddressMapper接口中进行抽象方法的设计

```java
/**
     * 根据收货地址id删除数据
     *
     * @param aid 地址id
     * @return 受影响的行数
     */
    Integer deleteByAid(@Param("aid") Integer aid);

    /**
     * 查找最新修改的地址数据
     *
     * @param uid 用户id
     * @return 地址数据
     */
    Address findLastModified(Integer uid);
```

#### 1.3配置sql映射

在AddressMapper.xml中编写抽象方法对应的sql语句

```xml
<delete id="deleteByAid">
        DELETE FROM t_address WHERE aid=#{aid}
    </delete>

    <select id="findLastModified" resultMap="AddressEntityMap">
        SELECT* FROM t_address WHERE uid=#{uid} ORDER BY modified_time DESC LIMIT 0,1
    </select>
```

#### 1.4单元测试

```java
@Test
    public void deleteByAid(){
        addressMapper.deleteByAid(6);
    }

    @Test
    public void findLastModified(){
        System.out.println(addressMapper.findLastModified(10));
    }
```

### 2.删除收货地址-业务层

#### 2.1规划异常

在执行删除的时候可能会导致未知的删除异常，则抛出DeleteException异常

```java
/** 删除数据时产生的异常 */
public class DeleteException extends ServiceException{
    public DeleteException() {
        super();
    }

    public DeleteException(String message) {
        super(message);
    }

    public DeleteException(String message, Throwable cause) {
        super(message, cause);
    }

    public DeleteException(Throwable cause) {
        super(cause);
    }

    protected DeleteException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

#### 2.2抽象方法

在IAddressService接口中设计抽象方法

```java
/**
     * 删除用户选中的收货地址
     * @param aid 收货地址id
     * @param uid 用户id
     * @param username 修改执行人
     */
    void deleteAddress(Integer aid,
                       Integer uid,
                       String username);
```

#### 2.3实现抽象方法

在AddressServiceImpl中实现抽象方法

```java
@Override
    public void deleteAddress(Integer aid, Integer uid, String username) {
        //检测地址是否存在
        Address result = addressMapper.findByAid(aid);
        if (result == null){
            throw new AddressNotFoundException("收货地址不存在");
        }
        //检测当前获取到的收货地址的归属
        if (!result.getUid().equals(uid)){
            throw new AccessDeniedException("非法数据访问");
        }
        //删除用户选中的收货地址
        Integer rows = addressMapper.deleteByAid(aid);
        if (rows != 1){
            throw new DeleteException("删除数据产生未知的异常");
        }
        //用户地址总数是否为0
        Integer count = addressMapper.countByUid(uid);
        if (count == 0){
            return;
        }
        if(result.getIsDefault() == 0){
            return;
        }
        //如果当前要删除的收货地址是默认收货地址，则需要将最新修改的地址设置为默认收货地址
        Address address = addressMapper.findLastModified(uid);
        rows = addressMapper.updateDefaultByAid(address.getAid(),
                                         username,
                                         new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
        if (rows != 1){
            throw new UpdateException("更新数据时产生未知的异常");
        }
    }
```

#### 2.4单元测试

```java
@Test
    public void deleteAddress(){
        addressService.deleteAddress(9,9,"管理员");
    }
```

### 3.删除收货地址-控制层

#### 3.1处理异常

处理异常DeleteException异常

```java
else if(e instanceof DeleteException) {
            result.setState(5002);
            result.setMesssge("删除数据时产生未知异常");
        }
```

#### 3.2设计请求

```
请求路径：/addresses/{aid}/delete_address
请求方式：POST
请求数据：HttpSession session,Integer aid
响应结果：JsonResult<Void>
```

#### 3.3处理请求

在AddressController编写请求处理方法的实现

```java
@RequestMapping("/{aid}/delete_address")
    public JsonResult<Void> deleteAddress(@PathVariable("aid")Integer aid,
                                          HttpSession session){
        
        addressService.deleteAddress(   aid,
                                        getuidFromSession(session),
                                        getUsernameFromSession(session));
        return new JsonResult<>(OK);
    }
```

#### 3.4单元测试

```
http://localhost:8080/addresses/5/delete_address
```

### 4.删除收货地址-前端页面

在address.html页面中来添加删除按钮的事件。

```js
<a onclick="delete(#{aid}})" class="btn btn-xs add-del btn-info"><span class="fa fa-trash-o"></span> 删除</a>
```

编写deleteAddress(aid)方法

```js
/** 删除地址方法 */
			function deleteAddress(aid) {
				$.ajax({
					url:"/addresses/"+aid+"/delete_address",
					type:"POST",
					dataType:"JSON",
					success:function(json){
						if (json.state === 200 ){
							alert("删除收货地址成功");
							//重新加载收货地址
							showAddressList();
							//刷新当前页面
							location.reload();
						}else{
							alert("删除收货地址失败");
						}
					},
					error:function(xhr){
						alert("删除收货地址时产生未知异常"+xhr.message);
					}
				});
			}
```

## 修改收货地址

### 1.修改收货地址-持久层

#### 1.1sql语句的规划

- 在修改之前判断该数据是否存在，判断该条地址是否属于当前用户。

- 使用aid来查询当前收货地址的信息（已写）

- 更新用户的收货地址信息

```sql
update t_address set(除了aid、uid、创建者和创建时间的字段) where aid = #{aid} 
```

#### 1.2设计抽象方法

在AddressMapper接口中进行抽象方法的设计

```java
 /**
     * 更新当前收货地址信息
     * @param address 新地址信息
     * @return 影响的行数
     */
    Integer updateAddress(Address address);
```

#### 1.3配置sql映射

在AddressMapper.xml中编写抽象方法对应的sql语句

```xml
<update id="updateAddress">
        UPDATE  t_address
        SET
            name=#{name},zip=#{zip},address=#{address},phone=#{phone},tel=#{tel},tag=#{tag},
            province_name={provinceName},province_code={provinceCode},city_name={cityName},
            city_code={cityCode},area_name={areaName},area_code={areaCode},
            modified_user=#{modifiedUser},modified_time=#{modifiedTime}
        WHERE
            aid=#{aid}
    </update>
```

#### 1.4单元测试

```java
 @Test
    public void updateAddress(){
        Address address = new Address();
        address.setName("小明");
        address.setAid(10);
        addressMapper.updateAddress(address);
    }
```

### 2.修改收货地址-业务层

#### 2.1异常规划

当前地址不存在抛出AddressNotFoundException异常

访问的数据不是当前登陆用户的数据，非法访问：AccessDeniedException异常

更新数据时发生未知的异常：UpdateException异常

#### 2.2抽象方法

```java
/**
     * 更新用户选中收货地址的信息
     * @param address 新地址信息
     */
    void updateAddress(Integer aid,Integer uid,Address address,String username);
```

#### 2.3实现抽象方法

```java
       @Override
    public void updateAddress(Integer aid,Integer uid,Address address,String username ) {
        //检测地址是否存在
        Address result = addressMapper.findByAid(aid);
        if (result == null){
            throw new AddressNotFoundException("收货地址不存在");
        }
        //检测当前获取到的收货地址的归属
        if (!result.getUid().equals(uid)){
            throw new AccessDeniedException("非法数据访问");
        }
        //补全表单中没有的字段
        address.setAid(aid);
        address.setUid(uid);
        address.setModifiedUser(username);
        address.setModifiedTime(new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
        Integer rows = addressMapper.updateAddress(address);
        if (rows == 0){
            throw new UpdateException("修改收货地址信息时产生未知的异常");
        }
    }
```

#### 2.4单元测试

```java
@Test
    public void updateAddress(){
        Address address = new Address();
        address.setName("女朋友");
        addressService.updateAddress(10,9,"管理员",address);
        System.err.println(address);
    }
```

### 3.修改收货地址-控制层

#### 3.1处理相关异常

无

#### 3.2设计请求

```
请求路径：/addresses/{aid}/change_address
请求方式：POST
请求数据：HttpSession session,Integer aid
响应结果：JsonResult<Void>
```

```
请求路径：/addresses/queryOneAddress
请求方式：POST
请求数据：Integer aid
响应结果：JsonResult<Address>
```



#### 3.3处理请求

```java
 @RequestMapping("/{cga}/change_address")
    public JsonResult<Void> updateAddress(@PathVariable("cga")Integer aid,
                                          Address address,
                                          HttpSession session){
        addressService.updateAddress(aid,
                getuidFromSession(session),
                address,
                getUsernameFromSession(session));
        return new JsonResult<>(OK);
    }

    @RequestMapping("/queryOneAddress")
    public JsonResult<Address> queryOneAddress(Integer aid){
        Address address = addressService.queryAddressByAid(aid);
        //过滤部分不需要的字段
        address.setModifiedTime(null);
        address.setModifiedUser(null);
        address.setCreatedTime(null);
        address.setCreatedUser(null);
        return new JsonResult<>(OK,address);
    }
```

### 4.修改收货地址-前端页面

创建修改地址信息页面changeAddress.html

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <!--edge浏览器H5兼容设置-->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!--360浏览器H5兼容设置-->
    <meta name="renderer" content="webkit" />
    <title>电脑商城</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!--导入核心文件-->
    <script src="../bootstrap3/js/holder.js"></script>
    <link href="../bootstrap3/css/bootstrap.css" rel="stylesheet" type="text/css">
    <script src="../bootstrap3/jquery-1.9.1.min.js"></script>
    <script src="../bootstrap3/js/bootstrap.js"></script>
    <!-- 字体图标 -->
    <link rel="stylesheet" href="../bootstrap3/font-awesome-4.7.0/css/font-awesome.css" />
    <link rel="stylesheet" type="text/css" href="../css/layout.css" />
    <link rel="stylesheet" type="text/css" href="../css/top.css" />
    <link rel="stylesheet" type="text/css" href="../css/footer.css" />
</head>

<body>
<!--头部开始-->
<div class="header"></div>
<!--头部结束-->

<!--中间导航条开始 -->
<div class="middleNavigation"></div>
<!--中间导航条结束-->

<div class="container">
    <div class="col-md-2">
        <!--左侧导航开始-->
        <div class="panel-group" id="accordion">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <!--主选项：我的订单-->
                    <p class="panel-title">
                        <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne">我的订单</a>
                    </p>
                </div>
                <div id="collapseOne" class="panel-collapse collapse">
                    <div class="panel-body">
                        <div><a href="orders.html">全部订单</a></div>
                        <div><a href="orders.html">待付款</a></div>
                        <div><a href="orders.html">待收货</a></div>
                        <div><a href="orders.html">待评价</a></div>
                        <div><a href="orders.html">退货退款</a></div>
                    </div>
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <!--主选项：资料修改-->
                    <p class="panel-title">
                        <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo">资料修改</a>
                    </p>
                </div>
                <div id="collapseTwo" class="panel-collapse collapse in">
                    <div class="panel-body">
                        <div><a href="password.html">修改密码</a></div>
                        <div><a href="userdata.html">个人资料</a></div>
                        <div><a href="upload.html">上传头像</a></div>
                        <div><a href="address.html"><b>收货管理</b></a></div>
                    </div>
                </div>
            </div>
        </div>
        <!--左侧导航结束-->
    </div>
    <div class="col-md-10">
        <div class="panel panel-default">
            <ul class="nav nav-tabs">
                <li><a href="password.html">修改密码</a></li>
                <li><a href="userdata.html">个人资料</a></li>
                <li><a href="upload.html">上传头像</a></li>
                <li class="active"><a href="#">收货管理</a></li>
            </ul>
            <div class="panel-body">
                <!--修改收货地址表单开始-->
                <form id="form-update-address" class="form-horizontal" role="form">
                    <div class="form-group">
                        <label class="col-md-2 control-label"></label>
                        <label class="col-md-4 control-label" style="color: red;font-size: larger">修改地址</label>
                        <label class="col-md-2 control-label"></label>
                    </div>
                    <div class="form-group">
                        <label class="col-md-2 control-label"><span class="txtred">*</span>收货人：</label>
                        <div class="col-md-8">
                            <input id="aid" name="aid" hidden="hidden" />
                            <input id="consigneesName" name="name" type="text" class="form-control" placeholder="请输入收货人姓名">
                        </div>
                    </div>
                    <div class="address_content" data-toggle="distpicker">
                        <div class="form-group">
                            <label class="col-md-2 control-label"><span class="txtred">*</span>省/直辖市：</label>
                            <div class="col-md-3">
                                <select id="province-list" name="provinceCode" class="form-control" data-province="---- 选择省 ----"></select>
                            </div>
                            <label class="col-md-2 control-label"><span class="txtred">*</span>城市：</label>
                            <div class="col-md-3">
                                <select id="city-list" name="cityCode" class="form-control" data-city="---- 选择市 ----"></select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="col-md-2 control-label"><span class="txtred">*</span>区县：</label>
                            <div class="col-md-3">
                                <select id="area-list" name="areaCode" class="form-control" data-district="---- 选择区 ----"></select>
                            </div>
                            <label class="col-md-2 control-label">邮政编码：</label>
                            <div class="col-md-3">
                                <input id="zip" name="zip" type="text" class="form-control" placeholder="请输入邮政编码">
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-md-2 control-label"><span class="txtred">*</span>详细地址：</label>
                        <div class="col-md-8">
                            <textarea id="address" name="address" class="form-control" rows="3" placeholder="输入详细的收货地址，小区名称、门牌号等"></textarea>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-md-2 control-label"><span class="txtred">*</span>手机：</label>
                        <div class="col-md-3">
                            <input id="phone" name="phone" type="text" class="form-control" placeholder="请输入手机号码">
                        </div>
                        <label class="col-md-2 control-label">固话：</label>
                        <div class="col-md-3">
                            <input id="tel" name="tel" type="text" class="form-control" placeholder="请输入固定电话号码">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-md-2 control-label">地址类型：</label>
                        <div class="col-md-8">
                            <input id="tag" name="tag" type="text" class="form-control" placeholder="请输入地址类型，如：家、公司或者学校">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-md-2 control-label"><a href="address.html">返回</a>&nbsp;&nbsp;&nbsp;</label>
                        <div class="col-sm-10">
                            <input id="updateAddress" type="button" class="col-md-1 btn btn-primary" value="修改" />
                            <input id="resetInfo" type="reset" class="col-md-offset-1 col-md-2 btn btn-primary" value="恢复原地址信息" />
                            <div id="error-msg" class="pull-left" style="color: red;font-weight:bold;padding-left: 15px;padding-top: 5px" ></div>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
<!--页脚开始-->

<div class="clearfix"></div>
<!--页脚开始-->
<div class="footer"></div>
<!--页脚结束-->

</body>

</html>
```

在changeAddress.html页面编写ajax请求

```js
 <script type="text/javascript">
            //value属性表示当前这个区域的code值
            let defaultOption = "<option value='0'>---- 请选择 ----</optionvalue>"

            $(document).ready(function () {
                showThisUserAddress();
                showProvinceList();
                //设置默认的”请选择“的值作为控件的默认值
                $("#province-list").append(defaultOption);
                $("#area-list").append(defaultOption);
                $("#city-list").append(defaultOption);
            });

            //省的下拉列表数据展示
            function showProvinceList(){
                $.ajax({
                    url: "/districts",
                    type: "POST",
                    data: "parent=86",
                    dataType: "JSON",
                    success: function (json) {
                        if (json.state === 200) {
                            let list = json.data;
                            for (let i = 0; i < list.length;i++){
                                let opt =
                                    "<option value='"+list[i].code+"'>"+list[i].name+"</option>"
                                $("#province-list").append(opt);
                                console.log(opt);
                            }
                        } else {
                            alert("省/直辖区信息加载失败！");
                        }
                    }
                });
            }

            /**
             * change函数用于监听某个控件是否发生改变，一旦发生就会触发
             * 需要传递一个function(){}
             */
            function getcity(){
                //先获取行政区父代码
                let parent = $("#province-list").val();
                console.log($("#province-list").val());
                //清空select下拉列表中的所有option元素
                $("#city-list").empty();
                $("#area-list").empty();
                //再填充默认值
                $("#city-list").append(defaultOption);
                $("#area-list").append(defaultOption);

                if(parent === 0){
                    return;
                }

                $.ajax({
                    url:"/districts",
                    type:"GET",
                    data:"parent="+parent,
                    dataType:"JSON",
                    success:function (json) {
                        if (json.state === 200) {
                            let list = json.data;
                            for (let i = 0; i < list.length;i++){
                                let opt =
                                    "<option value='"+list[i].code+"'>"+list[i].name+"</option>"
                                $("#city-list").append(opt);
                            }
                        } else {
                            alert("城市信息加载失败！");
                        }
                    }
                });
            }

            function getarea(){
                let parent = $("#city-list").val();
                //清空select下拉列表中的所有option元素
                $("#area-list").empty();
                //再填充默认值
                $("#area-list").append(defaultOption);

                if(parent === 0){
                    return;
                }

                $.ajax({
                    url:"/districts",
                    type:"GET",
                    data:"parent="+parent,
                    dataType:"JSON",
                    success:function (json) {
                        if (json.state === 200) {
                            let list = json.data;
                            for (let i = 0; i < list.length;i++){
                                let opt =
                                    "<option value='"+list[i].code+"'>"+list[i].name+"</option>"
                                $("#area-list").append(opt);
                            }
                        } else {
                            alert("区县信息加载失败！");
                        }
                    }
                });
            }

            //给重置信息按钮绑定单击事件
            function ResetInfo(){
                //发一次ajax请求，重新赋值所有内容
                showThisUserAddress();
            }

            //给修改按钮绑定单击事件
            function UpdateAddress(cga){

                console.log($("updateAddress"));
                //判断手机号和收货人是否为空
                let name = $("#consigneesName").val();
                let phone = $("#phone").val();
                if (phone === "" || name === ""){
                    $("#error-msg").html("请先填写需要修改的信息！");
                    return false;
                }
                $.ajax({
                    url : "/addresses/"+cga+"/change_address",
                    type: "post",
                    data: $("#form-update-address").serialize(), //获取表单的所有内容
                    dataType: "json",
                    success: function () {
                        alert("修改成功！")
                        location.href = "address.html"
                    },
                    error: function () {
                        alert("服务器出现故障，修改失败，请等待攻城狮修复！！")
                    }
                })
            }

            function showThisUserAddress(){
                //接收上一个页面传来的连接
                var hrefUrl = location.href;
                //以url中的"="为截断点，形成一个数组
                var param = hrefUrl.split("=")
                //decodeURI解码得到想要的参数
                var aid = decodeURI(param[1]);
                document.getElementById("updateAddress").setAttribute("onclick", "UpdateAddress(" + aid + ")");
                //在页面加载完成时自动发送此ajax请求并填充表单
                $.ajax({
                    url: "/addresses/queryOneAddress",
                    type: "get",
                    data: "aid=" + aid,
                    dataType: "json",
                    success:function (res) {
                        let address = res.data
                        let provinceStr = "<option value="+ address.provinceCode + ">"+ address.provinceName + "</option>"
                        let cityStr = "<option value="+ address.cityCode + ">" + address.cityName + "</option>"
                        let areaStr = "<option value="+ address.areaCode + ">" + address.areaName + "</option>"
                        //设置id和收货人姓名
                        $("#aid").val(address.aid)
                        $("#consigneesName").val(address.name)
                        //设置省市区
                        $("#province-list").append(provinceStr)
                        $("#city-list").append(cityStr)
                        $("#area-list").append(areaStr)
                        //设置邮政编码、地址、手机、固话、地址类型
                        $("#zip").val(address.zip)
                        $("#address").val(address.address)
                        $("#phone").val(address.phone)
                        $("#tel").val(address.tel)
                        $("#tag").val(address.tag)
                    }
                })
            }
    </script>
```

## 商品热销排行

### 1.商品-创建数据库

```sql
CREATE TABLE t_product (
  id int(20) NOT NULL COMMENT '商品id',
  category_id int(20) DEFAULT NULL COMMENT '分类id',
  item_type varchar(100) DEFAULT NULL COMMENT '商品系列',
  title varchar(100) DEFAULT NULL COMMENT '商品标题',
  sell_point varchar(150) DEFAULT NULL COMMENT '商品卖点',
  price bigint(20) DEFAULT NULL COMMENT '商品单价',
  num int(10) DEFAULT NULL COMMENT '库存数量',
  image varchar(500) DEFAULT NULL COMMENT '图片路径',
  status int(1) DEFAULT '1' COMMENT '商品状态  1：上架   2：下架   3：删除',
  priority int(10) DEFAULT NULL COMMENT '显示优先级',
  created_time datetime DEFAULT NULL COMMENT '创建时间',
  modified_time datetime DEFAULT NULL COMMENT '最后修改时间',
  created_user varchar(50) DEFAULT NULL COMMENT '创建人',
  modified_user varchar(50) DEFAULT NULL COMMENT '最后修改人',
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

### 2.商品-创建实体类

```java
/** 商品数据的实体类 */
public class Product extends BaseEntity implements Serializable {
    private Integer id;
    private Integer categoryId;
    private String itemType;
    private String title;
    private String sellPoint;
    private Long price;
    private Integer num;
    private String image;
    private Integer status;
    private Integer priority;

    // Generate: Getter and Setter、Generate hashCode() and equals()、toString()
}
```

### 3.商品-热销排行-持久层

#### 3.1规划需要执行的sql语句

```sql
SELECT * FROM t_product WHERE status=1 ORDER BY priority DESC LIMIT 0,4
```

#### 3.2接口与抽象方法

创建ProductMapper接口，再定义findHotList()的抽象方法

```java
public interface ProductMapper {
    
    //寻找热销商品列表
    List<Product> findHotList();
    
}
```

#### 3.3配置sql映射

创建ProductMapper.xml映射文件，再映射findHotList()方法对应的sql语句

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--namespace的属性：用于指定当前的映射文件和哪个接口文件映射，所以需要指定接口的文件路径，需要标注包的完整路径接口-->
<mapper namespace="com.cy.store.mapper.ProductMapper">
    <resultMap id="ProductEntityMap" type="com.cy.store.entity.Product">
        <id column="id" property="id"/>
        <result column="category_id" property="categoryId"/>
        <result column="item_type" property="itemType"/>
        <result column="sell_point" property="sellPoint"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>

    <!-- 查询热销商品的前四名：List<Product> findHostList() -->
    <select id="findHotList" resultMap="ProductEntityMap">
        SELECT *
        FROM t_product
        WHERE status=1 ORDER BY priority DESC LIMIT 0,4
    </select>


</mapper>
```

#### 3.4单元测试

在test下的mapper新建ProductMapperTests的测试类测试

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class ProductMapperTests {
    @Autowired
    private ProductMapper productMapper;

    @Test
    public void findHotList() {
        List<Product> list = productMapper.findHotList();
        System.out.println("count=" + list.size());
        for (Product item : list) {
            System.out.println(item);
        }
    }
}
```

### 4.商品-热销排行-业务层

#### 4.1规划异常

无

#### 4.2接口与抽象方法

创建com.cy.store.service.IProductService接口，并在接口中添加findHotList()方法

```java
/** 处理商品数据的业务层接口 */
public interface IProductService {

    /**
     * 查询热销商品的前四名
     * @return 热销商品前四名的集合
     */
    List<Product> findHotList();
}
```

#### 4.3实现抽象方法

创建com.cy.store.service.impl.ProductServiceImpl类，并添加@Service注解；在类中声明持久层对象以及实现接口中的方法

```java
/** 处理商品数据的业务层实现类 */
@Service
public class ProductServiceImpl implements IProductService {
    @Autowired
    private ProductMapper productMapper;

    @Override
    public List<Product> findHotList() {
        List<Product> list = productMapper.findHotList();
        for (Product product : list) {
            product.setPriority(null);
            product.setCreatedUser(null);
            product.setCreatedTime(null);
            product.setModifiedUser(null);
            product.setModifiedTime(null);
        }
        return list;
    }
}
```

#### 4.4单元测试

在com.cy.store.service包下创建测试类ProductServiceTests，并编写测试方法

```java
//@SpringBootTest:表示标注当前的类是一个测试类，不会随项目一块打包
@SpringBootTest
//启动单元测试类，需要传递一个SpringRunner.class
@RunWith(SpringRunner.class)
public class ProductServiceTests {
    @Autowired
    private IProductService productService;

    @Test
    public void findHotList() {
        try {
            List<Product> list = productService.findHotList();
            System.out.println("count=" + list.size());
            for (Product item : list) {
                System.out.println(item);
            }
        } catch (ServiceException e) {
            System.out.println(e.getClass().getSimpleName());
            System.out.println(e.getMessage());
        }
    }
}
```

### 5.商品-热销排行-控制层

#### 5.1处理异常

无

#### 5.2规划请求

```
请求路径：/products/hot_product
请求方式：GET
请求数据：无
响应结果：JsonResult<List<Product>>
是否拦截：否，需要将index.html和products/**添加到白名单
```

在LoginInterceptorConfigurer类中将products/**请求添加到白名单

```java
patterns.add("/products/**");
```

#### 5.3处理请求

创建com.cy.controller.ProductController类继承自BaseController类，类添加@RestController和@RequestMapping("products")注解，并在类中添加业务层对象。

```java
@RestController
@RequestMapping("products")
public class ProductController extends BaseController {
    @Autowired
    private IProductService productService;
}
```

在类中添加处理请求的getHotList()方法、

```java
@RequestMapping("hot_list")
public JsonResult<List<Product>> getHotList() {
    List<Product> data = productService.findHotList();
    return new JsonResult<List<Product>>(OK, data);
}
```

#### 5.4单元测试

```java
完成后启动项目，直接访问http://localhost:8080/products/hot_list进行测试
```

### 6.商品-热销排行-前端页面

在index.html页面中body标签内部的最后，添加展示热销排行商品的代码

```js
<script type="text/javascript">
			$(document).ready(function() {
				//展示热销商品
				showHotList();
			});

			function showHotList(){
				//先清空列表
				$("#hot-list").empty();
				//添加热销商品
				$.ajax({
					url: "/products/hot_list",
					type: "GET",
					dataType: "JSON",
					success: function(json) {
						let list = json.data;
						console.log("count=" + list.length);
						for (let i = 0; i < list.length; i++) {
							console.log(list[i].title);
							let html = '<div class="col-md-12">'
									+ '<div class="col-md-7 text-row-2"><a href="product.html?id=#{id}">#{title}</a></div>'
									+ '<div class="col-md-2">¥#{price}</div>'
									+ '<div class="col-md-3"><img src="..#{image}collect.png" class="img-responsive" /></div>'
									+ '</div>';

							html = html.replace(/#{id}/g, list[i].id);
							html = html.replace(/#{title}/g, list[i].title);
							html = html.replace(/#{price}/g, list[i].price);
							html = html.replace(/#{image}/g, list[i].image);

							$("#hot-list").append(html);
						}
					}
				});
			}
		</script>
```

## 显示商品详情

### 1.商品-显示商品详情-持久层

#### 1.1规划需要执行的sql语句

根据商品id显示商品详情

```sql
SELECT * FROM t_product WHERE id=?
```

#### 1.2接口与抽象方法

在ProductMapper接口中添加抽象方法

```java
//根据商品id查询商品详情
    Product findById(Integer id);
```

#### 1.3配置sql映射

在ProductMapper.xml文件中配置findById(Integer id)方法的映射

```xml
<!-- 根据商品id查询商品详情：Product findById(Integer id) -->
    <select id="findById" resultMap="ProductEntityMap">
        SELECT * FROM t_product WHERE id=#{id}
    </select>
```

#### 1.4单元测试

在ProductMapperTests测试类中添加测试方法

```java
@Test
    public void findById() {
        Integer id = 10000017;
        Product result = productMapper.findById(id);
        System.out.println(result);
    }
```

### 2.商品-显示商品详情-业务层

#### 2.1规划异常

如果商品数据不存在，应该抛出ProductNotFoundException，需要创建com.cy.store.service.ex.ProductNotFoundException异常

```java
/** 商品数据不存在的异常 */
public class ProductNotFoundException extends ServiceException {
    // Override Methods...
}
```

#### 2.2接口与抽象方法

在业务层IProductService接口中添加findById(Integer id)抽象方法

```java
/**
     * 根据商品id查询商品详情
     * @param id 商品id
     * @return 匹配的商品详情，如果没有匹配的数据则返回null
     */
    Product findById(Integer id);
```

#### 2.3实现抽象方法

在ProductServiceImpl类中，实现接口中的findById(Integer id)抽象方法

```java
@Override
    public Product findById(Integer id) {
        // 根据参数id调用私有方法执行查询，获取商品数据
        Product product = productMapper.findById(id);
        // 判断查询结果是否为null
        if (product == null) {
            // 是：抛出ProductNotFoundException
            throw new ProductNotFoundException("尝试访问的商品数据不存在");
        }
        // 将查询结果中的部分属性设置为null
        product.setPriority(null);
        product.setCreatedUser(null);
        product.setCreatedTime(null);
        product.setModifiedUser(null);
        product.setModifiedTime(null);
        // 返回查询结果
        return product;
    }
```

#### 2.4单元测试

在ProductServiceTests测试类中编写测试方法

```java
@Test
    public void findById() {
        try {
            Integer id = 10000017;
            Product result = productService.findById(id);
            System.out.println(result);
        } catch (ServiceException e) {
            System.out.println(e.getClass().getSimpleName());
            System.out.println(e.getMessage());
        }
    }
```

### 3.商品-显示商品详情-控制层

#### 3.1处理异常

在BaseController类中的handleException()方法中添加处理ProductNotFoundException的异常

```java
else if(e instanceof ProductNotFoundException){
            result.setState(4006);
            result.setMesssge("商品数据不存在的异常");
        }
```

#### 3.2规划请求

```
请求路径：/products/{id}/details
请求方式：POST
请求数据：@PathVariable("id") Integer id
响应结果：JsonResult<Product>
```

#### 3.3处理请求

在ProductController类中添加处理请求的getById()方法

```java
@RequestMapping("{id}/details")
    public JsonResult<Product> findById(@PathVariable("id") Integer id) {
        Product data = productService.findById(id);
        return new JsonResult<>(OK, data);
    }
```

#### 3.4单元测试

直接访问http://localhost:8080/products/10000017/details进行测试

### 4.商品-显示商品详情-前端页面

引入jquery-getUrlParam.js文件,其封装了$.getUrlParam()方法，可以获取url内传递的参数

```js
<script type="text/javascript" src="../js/jquery-getUrlParam.js"></script>
```

在product.html页面中添加获取当前商品详情的代码

```js
<script type="text/javascript">
//获取到url传过来的参数
let id = $.getUrlParam("id");
console.log("id=" + id);
//加载商品的详细信息
$(document).ready(function() {
    $.ajax({
        url: "/products/" + id + "/details",
        type: "GET",
        dataType: "JSON",
        success: function(json) {
            if (json.state == 200) {
                console.log("title=" + json.data.title);
                $("#product-title").html(json.data.title);
                $("#product-sell-point").html(json.data.sellPoint);
                $("#product-price").html(json.data.price);

                for (let i = 1; i <= 5; i++) {
                    $("#product-image-" + i + "-big").attr("src", ".." + json.data.image + i + "_big.png");
                    $("#product-image-" + i).attr("src", ".." + json.data.image + i + ".jpg");
                }
            } else if (json.state == 4006) { // 商品数据不存在的异常
                location.href = "index.html";
            } else {
                alert("获取商品信息失败！" + json.message);
            }
        }
    });
});
</script>
```

## 加入购物车

### 1.购物车-创建数据库

在store数据库中创建t_cart用户数据表

```sql
CREATE TABLE t_cart (
	cid INT AUTO_INCREMENT COMMENT '购物车数据id',
	uid INT NOT NULL COMMENT '用户id',
	pid INT NOT NULL COMMENT '商品id',
	price BIGINT COMMENT '加入时商品单价',
	num INT COMMENT '商品数量',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (cid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

### 2.购物车-创建实体类

在com.cy.store.entity包下创建购物车的Cart实体类

```java
/** 购物车数据的实体类 */
public class Cart extends BaseEntity implements Serializable {
    private Integer cid;
    private Integer uid;
    private Integer pid;
    private Long price;
    private Integer num;

    // Generate: Getter and Setter、Generate hashCode() and equals()、toString()
}
```

### 3.购物车-添加购物车-持久层

#### 3.1规划需要执行的sql语句

向购物车表中插入商品数据

```sql
INSERT INTO t_cart (除了cid以外的字段列表) VALUES (匹配的值列表);
```

如果用户曾经将某个商品加入到购物车过，则点击“加入购物车”按钮只会对购物车中相同商品数量做递增操作

```sql
UPDATE t_cart SET num=? WHERE cid=?
```

关于判断“到底应该插入数据，还是修改数量”，可以通过“查询某用户是否已经添加某商品到购物车”来完成

```sql
SELECT * FROM t_cart WHERE uid=? AND pid=?
```

#### 3.2接口与抽象方法

```java
/** 处理购物车数据的持久层接口 */
public interface CartMapper {
    /**
     * 插入购物车数据
     * @param cart 购物车数据
     * @return 受影响的行数
     */
   Integer insert(Cart cart);

    /**
     * 修改购物车数据中商品的数量
     * @param cid 购物车数据的id
     * @param num 新的数量
     * @param modifiedUser 修改执行人
     * @param modifiedTime 修改时间
     * @return 受影响的行数
     */
    Integer updateNumByCid(Integer cid,
                           Integer num,
                           String modifiedUser,
                           LocalDate modifiedTime);

    /**
     * 根据用户id和商品id查询购物车中的数据
     * @param uid 用户id
     * @param pid 商品id
     * @return 匹配的购物车数据，如果该用户的购物车中并没有该商品，则返回null
     */
    Cart findByUidAndPid(Integer uid,
                    Integer pid);
}
```

#### 3.3配置sql映射

在resources.mapper文件夹下创建CartMapper.xml文件，并在文件中配置以上三个方法的映

```xml
<!--namespace的属性：用于指定当前的映射文件和哪个接口文件映射，所以需要指定接口的文件路径，需要标注包的完整路径接口-->
<mapper namespace="com.cy.store.mapper.CartMapper">
    <resultMap id="CartEntityMap" type="com.cy.store.entity.Cart">
        <id column="cid" property="cid"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>

    <insert id="insert" useGeneratedKeys="true" keyProperty="cid">
        INSERT INTO t_cart
            (uid, pid, price, num, created_user, created_time, modified_user, modified_time)
        VALUES
            (#{uid}, #{pid}, #{price}, #{num}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime})
    </insert>

    <update id="updateNumByCid">
        UPDATE
            t_cart
        SET
            num=#{num},
            modified_user=#{modifiedUser},
            modified_time=#{modifiedTime}
        WHERE
            cid=#{cid}
    </update>

    <select id="findByUidAndPid" resultMap="CartEntityMap">
        SELECT
            *
        FROM
            t_cart
        WHERE
            uid=#{uid} AND pid=#{pid}
    </select>

</mapper>
```

#### 3.4单元测试

在com.cy.store.mapper包下创建CartMapperTests测试类

```java
//@SpringBootTest:表示标注当前的类是一个测试类，不会随项目一块打包
@SpringBootTest
//启动单元测试类，需要传递一个SpringRunner.class
@RunWith(SpringRunner.class)
public class CartMapperTests {
    @Autowired
    private CartMapper cartMapper;

    @Test
    public void insert() {
        Cart cart = new Cart();
        cart.setUid(10);
        cart.setPid(10000013);
        cart.setNum(2);
        cart.setPrice(8000L);
        Integer rows = cartMapper.insert(cart);
        System.out.println("rows=" + rows);
    }

    @Test
    public void updateNumByCid(){
        Integer cid = 1;
        Integer num = 10;
        String modifiedUser = "购物车管理员";
        LocalDate modifiedTime = new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        Integer rows = cartMapper.updateNumByCid(cid, num, modifiedUser, modifiedTime);
        System.out.println("rows=" + rows);
    }

    @Test
    public void findByUidAndPid() {
        Integer uid = 10;
        Integer pid = 10000013;
        Cart result = cartMapper.findByUidAndPid(uid, pid);
        System.out.println(result);
    }
}
```

### 4.购物车-添加购物车-业务层

#### 4.1规划异常

在插入数据时，可能抛出InsertException异常

在修改数据时，可能抛出UpdateException异常

#### 4.2接口与抽象方法

#### 4.3实现抽象方法

#### 4.4单元测试

### 5.购物车-添加购物车-控制层

#### 5.1处理异常

#### 5.2规划请求

#### 5.3处理请求

#### 5.4单元测试

### 6.购物车-添加购物车-前端页面
